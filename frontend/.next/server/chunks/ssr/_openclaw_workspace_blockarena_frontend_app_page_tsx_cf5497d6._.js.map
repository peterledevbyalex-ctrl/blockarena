{"version":3,"sources":["../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/query-core/build/modern/queryObserver.js","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/build/modern/QueryErrorResetBoundary.js","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/build/modern/errorBoundaryUtils.js","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/build/modern/IsRestoringProvider.js","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/build/modern/suspense.js","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/build/modern/useBaseQuery.js","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/build/modern/useQuery.js","../../../../../../../../.openclaw/workspace/blockarena/frontend/hooks/useArena.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/CountdownTimer.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/ArenaCard.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/hooks/useSoundEffects.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/PredictionPanel.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/PriceChart.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/TierSelector.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/Confetti.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/FireRain.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/ScreenShake.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/ArenaCountdown.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/ShareCard.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/components/LiveSpectatorBar.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/hooks/useMiniBlocks.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/hooks/useSwipe.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/app/page.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/lib/contract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/constants/blob.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/blob/commitmentsToVersionedHashes.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/chain/assertCurrentChain.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/readContract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/signature/recoverAddress.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/transaction/getTransactionType.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/wagmi/src/utils/query.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/actions/getChainId.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/wagmi/src/hooks/useReadContract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/wagmi/src/hooks/useChainId.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/constants/kzg.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/wallet/prepareTransactionRequest.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/query/utils.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/actions/watchChainId.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/formatters/transaction.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/query/readContract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/errors/getContractError.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/estimateGas.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/query/writeContract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/errors/blob.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/errors/block.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/errors/getTransactionError.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/actions/writeContract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/query-core/src/queryObserver.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/wallet/writeContract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/errors/getEstimateGasError.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/blob/toBlobs.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/wallet/sendTransaction.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/hash/sha256.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/estimateFeesPerGas.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/authorization/recoverAuthorizationAddress.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/getBlock.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/wagmi/src/hooks/useWriteContract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/signature/recoverPublicKey.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/actions/getConnectorClient.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/fillTransaction.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/formatters/block.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/errors/account.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/abitype/src/human-readable/parseAbiParameters.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/errors/estimateGas.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/src/useQuery.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/authorization/hashAuthorization.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/estimateMaxPriorityFeePerGas.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/encoding/toRlp.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/abi/encodePacked.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/actions/readContract.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/clients/transports/custom.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/src/errorBoundaryUtils.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/src/suspense.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40wagmi/core/src/utils/getAction.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/errors/fee.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/accounts/utils/publicKeyToAddress.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40noble/hashes/src/sha256.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/getAction.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/lib/predictions.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/blob/blobsToCommitments.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/blob/commitmentToVersionedHash.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/blob/blobsToProofs.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/src/useBaseQuery.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/%40tanstack/react-query/src/QueryErrorResetBoundary.tsx","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/getGasPrice.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/getChainId.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/wallet/sendRawTransaction.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/actions/public/getTransactionCount.ts","../../../../../../../../.openclaw/workspace/blockarena/frontend/node_modules/viem/utils/blob/toBlobSidecars.ts"],"sourcesContent":["// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nimport { timeoutManager } from \"./timeoutManager.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key);\n        onPropTracked?.(key);\n        if (key === \"promise\") {\n          this.trackProp(\"data\");\n          if (!this.options.experimental_prefetchInRender && this.#currentThenable.status === \"pending\") {\n            this.#currentThenable.reject(\n              new Error(\n                \"experimental_prefetchInRender feature flag is not enabled\"\n              )\n            );\n          }\n        }\n        return Reflect.get(target, key);\n      }\n    });\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = timeoutManager.setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = timeoutManager.setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      timeoutManager.clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      timeoutManager.clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const hasResultData = nextResult.data !== void 0;\n      const isErrorWithoutData = nextResult.status === \"error\" && !hasResultData;\n      const finalizeThenableIfPossible = (thenable) => {\n        if (isErrorWithoutData) {\n          thenable.reject(nextResult.error);\n        } else if (hasResultData) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (isErrorWithoutData || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (!isErrorWithoutData || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    this.#notify({ listeners: shouldNotifyListeners() });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== \"static\") {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ jsx(QueryErrorResetBoundaryContext.Provider, { value, children: typeof children === \"function\" ? children(value) : children });\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map","\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"@tanstack/query-core\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary, query) => {\n  const throwOnError = query?.state.error && typeof options.throwOnError === \"function\" ? shouldThrowError(options.throwOnError, [query.state.error, query]) : options.throwOnError;\n  if (options.suspense || options.experimental_prefetchInRender || throwOnError) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map","\"use client\";\n\n// src/IsRestoringProvider.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=IsRestoringProvider.js.map","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    const MIN_SUSPENSE_TIME_MS = 1e3;\n    const clamp = (value) => value === \"static\" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);\n    const originalStaleTime = defaultedOptions.staleTime;\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => clamp(originalStaleTime(...args)) : clamp(originalStaleTime);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(\n        defaultedOptions.gcTime,\n        MIN_SUSPENSE_TIME_MS\n      );\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { isServer, noop, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { useIsRestoring } from \"./IsRestoringProvider.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const client = useQueryClient(queryClient);\n  const defaultedOptions = client.defaultQueryOptions(options);\n  client.getDefaultOptions().queries?._experimental_beforeQuery?.(\n    defaultedOptions\n  );\n  const query = client.getQueryCache().get(defaultedOptions.queryHash);\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`\n      );\n    }\n  }\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureSuspenseTimers(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary, query);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions);\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query,\n    suspense: defaultedOptions.suspense\n  })) {\n    throw result.error;\n  }\n  ;\n  client.getDefaultOptions().queries?._experimental_afterQuery?.(\n    defaultedOptions,\n    result\n  );\n  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {\n    const promise = isNewCacheEntry ? (\n      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n    ) : (\n      // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n      query?.promise\n    );\n    promise?.catch(noop).finally(() => {\n      observer.updateResult();\n    });\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map","\"use client\";\n\n// src/useQuery.ts\nimport { QueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useQuery(options, queryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient);\n}\nexport {\n  useQuery\n};\n//# sourceMappingURL=useQuery.js.map","'use client';\n\nimport { useReadContract, useWriteContract, useAccount } from 'wagmi';\nimport { keccak256, encodePacked, encodeAbiParameters, parseAbiParameters, toHex } from 'viem';\nimport { ARENA_ENGINE_ADDRESS, ARENA_ENGINE_ABI } from '@/lib/contract';\nimport { encodePredictions } from '@/lib/predictions';\n\n/**\n * MegaETH Gas Constants\n * - Base fee: fixed 0.001 gwei (10^6 wei). DO NOT use eth_gasPrice (adds 20% buffer).\n * - Intrinsic gas: 60,000 (not 21K like Ethereum).\n * - Use eth_sendRawTransactionSync (EIP-7966) for instant receipts ‚Äî no polling needed.\n */\nconst MEGAETH_GAS_PRICE = 1_000_000n; // 0.001 gwei ‚Äî hardcoded per MegaETH docs\n\nexport function useArenaCount() {\n  return useReadContract({\n    address: ARENA_ENGINE_ADDRESS,\n    abi: ARENA_ENGINE_ABI,\n    functionName: 'nextArenaId',\n  });\n}\n\nexport function useArena(arenaId: bigint) {\n  return useReadContract({\n    address: ARENA_ENGINE_ADDRESS,\n    abi: ARENA_ENGINE_ABI,\n    functionName: 'getArena',\n    args: [arenaId],\n  });\n}\n\nexport function usePlayerState(arenaId: bigint, player?: `0x${string}`) {\n  return useReadContract({\n    address: ARENA_ENGINE_ADDRESS,\n    abi: ARENA_ENGINE_ABI,\n    functionName: 'getPlayerState',\n    args: player ? [arenaId, player] : undefined,\n    query: { enabled: !!player },\n  });\n}\n\nexport function useGodStreak(player?: `0x${string}`) {\n  return useReadContract({\n    address: ARENA_ENGINE_ADDRESS,\n    abi: ARENA_ENGINE_ABI,\n    functionName: 'godStreak',\n    args: player ? [player] : undefined,\n    query: { enabled: !!player },\n  });\n}\n\nexport function useEntryFee(tier: number) {\n  return useReadContract({\n    address: ARENA_ENGINE_ADDRESS,\n    abi: ARENA_ENGINE_ABI,\n    functionName: 'getEntryFee',\n    args: [tier],\n  });\n}\n\nexport function useJoinArena() {\n  const { writeContract } = useWriteContract();\n  return (arenaId: bigint, entryFee: bigint) => {\n    writeContract({\n      address: ARENA_ENGINE_ADDRESS,\n      abi: ARENA_ENGINE_ABI,\n      functionName: 'joinArena',\n      args: [arenaId],\n      value: entryFee,\n      gas: 200_000n,\n      maxFeePerGas: MEGAETH_GAS_PRICE,\n      maxPriorityFeePerGas: 0n,\n    });\n  };\n}\n\nexport function useCommitPrediction() {\n  const { writeContract } = useWriteContract();\n  const { address } = useAccount();\n\n  return (arenaId: bigint, predictions: boolean[], salt: `0x${string}`) => {\n    if (!address) return;\n\n    const predWords = encodePredictions(predictions);\n\n    // commitHash = keccak256(abi.encodePacked(arenaId, player, salt, keccak256(abi.encode(predWords))))\n    const predHash = keccak256(\n      encodeAbiParameters(\n        parseAbiParameters('uint256[]'),\n        [predWords],\n      ),\n    );\n    const commitHash = keccak256(\n      encodePacked(\n        ['uint256', 'address', 'bytes32', 'bytes32'],\n        [arenaId, address, salt, predHash],\n      ),\n    );\n\n    writeContract({\n      address: ARENA_ENGINE_ADDRESS,\n      abi: ARENA_ENGINE_ABI,\n      functionName: 'commitPrediction',\n      args: [arenaId, commitHash],\n      gas: 100_000n,\n      maxFeePerGas: MEGAETH_GAS_PRICE,\n      maxPriorityFeePerGas: 0n,\n    });\n\n    // Store predictions + salt locally for reveal\n    if (typeof window !== 'undefined') {\n      localStorage.setItem(\n        `arena-${arenaId}-prediction`,\n        JSON.stringify({\n          predWords: predWords.map((w) => w.toString()),\n          salt,\n        }),\n      );\n    }\n  };\n}\n\nexport function useRevealPrediction() {\n  const { writeContract } = useWriteContract();\n\n  return (arenaId: bigint) => {\n    const stored = localStorage.getItem(`arena-${arenaId}-prediction`);\n    if (!stored) throw new Error('No stored prediction found');\n    const { predWords, salt } = JSON.parse(stored);\n    writeContract({\n      address: ARENA_ENGINE_ADDRESS,\n      abi: ARENA_ENGINE_ABI,\n      functionName: 'revealPrediction',\n      args: [arenaId, (predWords as string[]).map((w: string) => BigInt(w)), salt as `0x${string}`],\n      gas: 200_000n,\n      maxFeePerGas: MEGAETH_GAS_PRICE,\n      maxPriorityFeePerGas: 0n,\n    });\n  };\n}\n\n/** Generate a random salt for commitment */\nexport function generateSalt(): `0x${string}` {\n  return keccak256(toHex(crypto.getRandomValues(new Uint8Array(32))));\n}\n","'use client';\n\ninterface CountdownTimerProps {\n  blocksRemaining: number;\n  totalBlocks: number;\n  label?: string;\n}\n\nexport function CountdownTimer({ blocksRemaining, totalBlocks, label }: CountdownTimerProps) {\n  const progress = totalBlocks > 0 ? ((totalBlocks - blocksRemaining) / totalBlocks) * 100 : 0;\n  const isUrgent = blocksRemaining < totalBlocks * 0.1;\n\n  return (\n    <div className=\"w-full\">\n      {label && <div className=\"text-[10px] text-gray-500 uppercase tracking-wider mb-1\">{label}</div>}\n      <div className=\"relative h-2 bg-gray-800/50 rounded-full overflow-hidden\">\n        <div\n          className={`h-full rounded-full transition-all duration-300 ${\n            isUrgent\n              ? 'bg-gradient-to-r from-red-600 to-red-400 shadow-[0_0_10px_rgba(255,23,68,0.5)] animate-pulse'\n              : 'bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 shadow-[0_0_8px_rgba(139,92,246,0.3)]'\n          }`}\n          style={{ width: `${Math.min(progress, 100)}%` }}\n        />\n      </div>\n      <div className=\"flex justify-between text-[10px] mt-1\">\n        <span className={isUrgent ? 'neon-text-red font-bold' : 'text-gray-500'}>\n          {blocksRemaining} blocks\n        </span>\n        <span className=\"text-gray-600 font-display\">{progress.toFixed(0)}%</span>\n      </div>\n    </div>\n  );\n}\n","'use client';\n\nimport { useArena, useEntryFee, useJoinArena } from '@/hooks/useArena';\nimport { formatEther } from 'viem';\nimport { TIER_CONFIG, TIER_FROM_INDEX, type ArenaTier } from '@/types';\nimport { CountdownTimer } from './CountdownTimer';\nimport { motion } from 'framer-motion';\n\ninterface ArenaCardProps {\n  arenaId: bigint;\n  currentBlock: bigint;\n}\n\nexport function getTierFromIndex(tierIndex: number): ArenaTier {\n  return TIER_FROM_INDEX[tierIndex] ?? 'low';\n}\n\nconst NEON_TIER: Record<ArenaTier, { gradient: string; glow: string; border: string }> = {\n  low: { gradient: 'from-green-900/30 to-green-900/10', glow: 'shadow-[0_0_15px_rgba(57,255,20,0.15)]', border: 'border-green-500/30' },\n  mid: { gradient: 'from-blue-900/30 to-blue-900/10', glow: 'shadow-[0_0_15px_rgba(0,212,255,0.15)]', border: 'border-blue-500/30' },\n  high: { gradient: 'from-purple-900/30 to-purple-900/10', glow: 'shadow-[0_0_15px_rgba(191,0,255,0.15)]', border: 'border-purple-500/30' },\n  vip: { gradient: 'from-yellow-900/30 to-yellow-900/10', glow: 'shadow-[0_0_15px_rgba(255,215,0,0.2)]', border: 'border-yellow-500/30' },\n};\n\nexport function ArenaCard({ arenaId, currentBlock }: ArenaCardProps) {\n  const { data: arena } = useArena(arenaId);\n  const tierIndex = arena ? Number(arena.tier) : 0;\n  const { data: entryFee } = useEntryFee(tierIndex);\n\n  if (!arena) {\n    return <div className=\"h-32 rounded-xl skeleton\" />;\n  }\n\n  const startBlock = BigInt(arena.startBlock);\n  const endBlock = BigInt(arena.endBlock);\n  const isJoinable = currentBlock < startBlock;\n  const isActive = currentBlock >= startBlock && currentBlock <= endBlock;\n  const isEnded = currentBlock > endBlock;\n  const tier = getTierFromIndex(tierIndex);\n  const cfg = TIER_CONFIG[tier];\n  const neon = NEON_TIER[tier];\n  const fee = entryFee ?? 0n;\n\n  const totalBlocks = Number(endBlock - startBlock);\n  const blocksRemaining = isActive ? Number(endBlock - currentBlock) : 0;\n\n  return (\n    <div className={`border ${neon.border} rounded-xl p-4 bg-gradient-to-br ${neon.gradient} ${neon.glow} transition-all hover:scale-[1.01] backdrop-blur-sm`}>\n      <div className=\"flex justify-between items-center mb-3\">\n        <div className=\"flex items-center gap-2\">\n          <h3 className=\"font-display text-lg font-bold text-white\">#{arenaId.toString()}</h3>\n          <span className={`text-[10px] font-bold px-2 py-0.5 rounded-full ${cfg.bg} ${cfg.color} border ${cfg.border} uppercase tracking-wider`}>\n            {cfg.label}\n          </span>\n        </div>\n        <div className=\"flex items-center gap-1.5\">\n          {isActive && <span className=\"w-2 h-2 rounded-full bg-red-500 animate-pulse\" />}\n          <span className={`text-xs font-bold ${isActive ? 'text-red-400' : isEnded ? 'text-gray-500' : 'text-green-400'}`}>\n            {arena.finalized ? 'üèÜ DONE' : isEnded ? '‚è≥ REVEAL' : isActive ? 'LIVE' : 'OPEN'}\n          </span>\n        </div>\n      </div>\n\n      <div className=\"grid grid-cols-3 gap-2 text-sm mb-3\">\n        <div className=\"text-center\">\n          <div className=\"text-gray-500 text-[10px] uppercase\">Entry</div>\n          <div className=\"font-display text-sm font-bold text-white\">{fee > 0n ? formatEther(fee) : cfg.fee}</div>\n        </div>\n        <div className=\"text-center\">\n          <div className=\"text-gray-500 text-[10px] uppercase\">Pot</div>\n          <div className=\"font-display text-sm font-bold neon-text-gold\">{formatEther(arena.pot)}</div>\n        </div>\n        <div className=\"text-center\">\n          <div className=\"text-gray-500 text-[10px] uppercase\">Players</div>\n          <div className=\"font-display text-sm font-bold text-white\">{arena.playerCount.toString()}</div>\n        </div>\n      </div>\n\n      {isActive && (\n        <div className=\"mb-3\">\n          <CountdownTimer blocksRemaining={blocksRemaining} totalBlocks={totalBlocks} />\n        </div>\n      )}\n\n      {isJoinable && <JoinButton arenaId={arenaId} fee={fee} tier={tier} cfgFee={cfg.fee} />}\n\n      {isActive && (\n        <div className=\"text-center py-1\">\n          <span className=\"font-display text-xs neon-text-red animate-neon-pulse font-bold tracking-widest\">\n            üî¥ LIVE ‚Äî {blocksRemaining} BLOCKS\n          </span>\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction JoinButton({ arenaId, fee, tier, cfgFee }: { arenaId: bigint; fee: bigint; tier: ArenaTier; cfgFee: string }) {\n  const joinArena = useJoinArena();\n  const displayFee = fee > 0n ? formatEther(fee) : cfgFee;\n\n  return (\n    <motion.button\n      whileTap={{ scale: 0.95 }}\n      onClick={(e) => { e.stopPropagation(); joinArena(arenaId, fee); }}\n      className={`w-full py-3 rounded-xl font-display font-bold text-base tracking-wider active:scale-95 transition-all ${\n        tier === 'vip' ? 'btn-neon-green' : 'btn-neon-green'\n      }`}\n    >\n      ‚ö° JOIN ({displayFee} ETH)\n    </motion.button>\n  );\n}\n\nexport { getTierFromIndex as getTier };\n","'use client';\n\nimport { useCallback, useRef, useEffect, useState } from 'react';\n\nexport function useSoundEffects() {\n  const ctxRef = useRef<AudioContext | null>(null);\n  const [muted, setMuted] = useState(true);\n\n  useEffect(() => {\n    const stored = localStorage.getItem('blockarena-muted');\n    if (stored !== null) setMuted(stored === 'true');\n\n    const handler = (e: Event) => setMuted((e as CustomEvent).detail);\n    window.addEventListener('blockarena-mute', handler);\n    return () => window.removeEventListener('blockarena-mute', handler);\n  }, []);\n\n  const getCtx = useCallback(() => {\n    if (!ctxRef.current) ctxRef.current = new AudioContext();\n    return ctxRef.current;\n  }, []);\n\n  const playTone = useCallback(\n    (freq: number, duration: number, type: OscillatorType = 'sine', gain = 0.3) => {\n      if (muted) return;\n      try {\n        const ctx = getCtx();\n        const osc = ctx.createOscillator();\n        const g = ctx.createGain();\n        osc.type = type;\n        osc.frequency.value = freq;\n        g.gain.setValueAtTime(gain, ctx.currentTime);\n        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);\n        osc.connect(g).connect(ctx.destination);\n        osc.start();\n        osc.stop(ctx.currentTime + duration);\n      } catch { /* Audio not available */ }\n    },\n    [getCtx, muted],\n  );\n\n  const playTick = useCallback(() => {\n    playTone(1200, 0.05, 'sine', 0.15);\n  }, [playTone]);\n\n  const playCorrect = useCallback(() => {\n    playTone(880, 0.1, 'sine', 0.2);\n    setTimeout(() => playTone(1100, 0.15, 'sine', 0.2), 80);\n  }, [playTone]);\n\n  const playWin = useCallback(() => {\n    [523, 659, 784, 1047].forEach((f, i) => {\n      setTimeout(() => playTone(f, 0.2, 'sine', 0.25), i * 100);\n    });\n  }, [playTone]);\n\n  const playLoss = useCallback(() => {\n    playTone(300, 0.3, 'sawtooth', 0.15);\n    setTimeout(() => playTone(200, 0.5, 'sawtooth', 0.1), 200);\n  }, [playTone]);\n\n  const playStreak = useCallback((milestone: number) => {\n    const base = milestone >= 25 ? 6 : milestone >= 10 ? 5 : 4;\n    const freqs = [523, 659, 784, 1047, 1319, 1568].slice(0, base);\n    freqs.forEach((f, i) => {\n      setTimeout(() => playTone(f, 0.25, 'sine', 0.3), i * 70);\n    });\n  }, [playTone]);\n\n  const playCountdown = useCallback(() => {\n    playTone(800, 0.08, 'square', 0.12);\n  }, [playTone]);\n\n  const playGo = useCallback(() => {\n    playTone(1047, 0.3, 'sine', 0.35);\n    setTimeout(() => playTone(1319, 0.4, 'sine', 0.3), 150);\n  }, [playTone]);\n\n  return { playTick, playCorrect, playWin, playLoss, playStreak, playCountdown, playGo, muted };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useCommitPrediction, useRevealPrediction, generateSalt } from '@/hooks/useArena';\nimport { useSoundEffects } from '@/hooks/useSoundEffects';\nimport { GodStreak } from './GodStreak';\nimport { motion, AnimatePresence } from 'framer-motion';\n\ninterface PredictionPanelProps {\n  arenaId: bigint;\n  numTicks: number;\n  isActive: boolean;\n  isEnded: boolean;\n  onWin?: () => void;\n  onStreak?: () => void;\n  onShare?: () => void;\n}\n\nexport function PredictionPanel({ arenaId, numTicks, isActive, isEnded, onWin, onStreak, onShare }: PredictionPanelProps) {\n  const [predictions, setPredictions] = useState<boolean[]>(new Array(numTicks).fill(false));\n  const [committed, setCommitted] = useState(false);\n  const [currentStreak, setCurrentStreak] = useState(0);\n  const [accuracy, setAccuracy] = useState(0);\n  const commitPrediction = useCommitPrediction();\n  const revealPrediction = useRevealPrediction();\n  const { playTick, playCorrect, playWin, playStreak: playStreakSound } = useSoundEffects();\n\n  const togglePrediction = useCallback((index: number) => {\n    playTick();\n    setPredictions(prev => {\n      const next = [...prev];\n      next[index] = !next[index];\n      return next;\n    });\n  }, [playTick]);\n\n  const setAllUp = () => setPredictions(new Array(numTicks).fill(true));\n  const setAllDown = () => setPredictions(new Array(numTicks).fill(false));\n  const randomize = () => setPredictions(Array.from({ length: numTicks }, () => Math.random() > 0.5));\n\n  const handleCommit = () => {\n    const salt = generateSalt();\n    commitPrediction(arenaId, predictions, salt);\n    setCommitted(true);\n    playWin();\n  };\n\n  const handleReveal = () => {\n    revealPrediction(arenaId);\n    onShare?.();\n  };\n\n  // Streak calculation\n  let maxStreak = 0;\n  let streak = 0;\n  for (const p of predictions) {\n    if (p) { streak++; maxStreak = Math.max(maxStreak, streak); }\n    else streak = 0;\n  }\n  const upCount = predictions.filter(Boolean).length;\n\n  const isLargeTape = numTicks > 256;\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 20 }}\n      animate={{ opacity: 1, y: 0 }}\n      className=\"glass-card rounded-2xl p-5 border border-purple-500/20\"\n    >\n      <div className=\"flex items-center justify-between mb-4\">\n        <h3 className=\"font-display text-lg font-bold text-white\">\n          PREDICTIONS\n        </h3>\n        <span className=\"text-xs text-gray-500 font-display\">{numTicks} TICKS</span>\n      </div>\n\n      {/* Live accuracy */}\n      <div className=\"flex items-center gap-4 mb-4\">\n        <div className=\"flex-1 flex items-center gap-2\">\n          <div className=\"text-sm text-gray-400\">Accuracy</div>\n          <div className=\"font-display text-lg font-bold neon-text-green\">{upCount > 0 ? ((upCount / numTicks) * 100).toFixed(0) : 0}%</div>\n        </div>\n        {currentStreak > 0 && (\n          <motion.div\n            initial={{ scale: 0 }}\n            animate={{ scale: 1 }}\n            className=\"px-3 py-1 rounded-full bg-orange-500/20 border border-orange-500/30 text-orange-400 text-sm font-bold\"\n          >\n            üî• {currentStreak} in a row!\n          </motion.div>\n        )}\n      </div>\n\n      {maxStreak >= 3 && (\n        <div className=\"mb-4\">\n          <GodStreak streak={maxStreak} best={maxStreak} />\n        </div>\n      )}\n\n      {isActive && !committed && (\n        <>\n          {/* Quick actions */}\n          <div className=\"flex gap-2 mb-4\">\n            <button onClick={setAllUp} className=\"flex-1 py-2 text-sm font-bold rounded-lg bg-green-900/30 border border-green-500/20 text-green-400 hover:bg-green-900/50 active:scale-95 transition-all\">\n              ALL ‚Üë\n            </button>\n            <button onClick={setAllDown} className=\"flex-1 py-2 text-sm font-bold rounded-lg bg-red-900/30 border border-red-500/20 text-red-400 hover:bg-red-900/50 active:scale-95 transition-all\">\n              ALL ‚Üì\n            </button>\n            <button onClick={randomize} className=\"flex-1 py-2 text-sm font-bold rounded-lg glass-card hover:bg-white/10 active:scale-95 transition-all\">\n              üé≤ MIX\n            </button>\n          </div>\n\n          {/* Prediction count */}\n          <div className=\"flex justify-between text-xs text-gray-500 mb-2\">\n            <span className=\"neon-text-green\">{upCount} ‚Üë</span>\n            <span className=\"neon-text-red\">{numTicks - upCount} ‚Üì</span>\n          </div>\n\n          {isLargeTape ? (\n            <div className=\"mb-4\">\n              <div className=\"flex h-20 rounded-xl overflow-hidden border border-gray-700/50\">\n                {Array.from({ length: Math.min(numTicks, 300) }).map((_, i) => {\n                  const idx = Math.floor((i / 300) * numTicks);\n                  return (\n                    <div\n                      key={i}\n                      onClick={() => {\n                        const next = [...predictions];\n                        const chunkSize = Math.ceil(numTicks / 300);\n                        const start = Math.floor((i / 300) * numTicks);\n                        const val = !next[start];\n                        for (let j = start; j < Math.min(start + chunkSize, numTicks); j++) next[j] = val;\n                        setPredictions(next);\n                        playTick();\n                      }}\n                      className={`flex-1 cursor-pointer transition-colors ${\n                        predictions[idx]\n                          ? 'bg-green-500 shadow-[inset_0_0_10px_rgba(57,255,20,0.3)]'\n                          : 'bg-red-500 shadow-[inset_0_0_10px_rgba(255,23,68,0.3)]'\n                      }`}\n                    />\n                  );\n                })}\n              </div>\n              <p className=\"text-[10px] text-gray-600 mt-1\">Tap to toggle ¬∑ Each bar ‚âà {Math.ceil(numTicks / 300)} ticks</p>\n            </div>\n          ) : (\n            <div className=\"flex flex-wrap gap-1.5 mb-4 max-h-64 overflow-y-auto pr-1\">\n              {predictions.map((pred, i) => (\n                <motion.button\n                  key={i}\n                  whileTap={{ scale: 0.85 }}\n                  onClick={() => togglePrediction(i)}\n                  className={`w-12 h-12 sm:w-10 sm:h-10 rounded-lg text-sm font-bold transition-all touch-manipulation ${\n                    pred\n                      ? 'bg-green-500 shadow-[0_0_12px_rgba(57,255,20,0.4)] text-black'\n                      : 'bg-red-500 shadow-[0_0_12px_rgba(255,23,68,0.4)] text-white'\n                  }`}\n                >\n                  {pred ? '‚Üë' : '‚Üì'}\n                </motion.button>\n              ))}\n            </div>\n          )}\n\n          <motion.button\n            whileTap={{ scale: 0.95 }}\n            onClick={handleCommit}\n            className=\"w-full py-4 rounded-xl font-display font-bold text-lg tracking-wider bg-gradient-to-r from-purple-600 to-blue-600 shadow-[0_0_25px_rgba(139,92,246,0.3)] hover:shadow-[0_0_35px_rgba(139,92,246,0.4)] transition-all\"\n          >\n            ‚ö° COMMIT PREDICTIONS\n          </motion.button>\n        </>\n      )}\n\n      {committed && isActive && (\n        <motion.div\n          initial={{ opacity: 0, scale: 0.9 }}\n          animate={{ opacity: 1, scale: 1 }}\n          className=\"text-center py-8\"\n        >\n          <div className=\"text-4xl mb-3 animate-heartbeat\">‚úÖ</div>\n          <div className=\"font-display text-lg font-bold neon-text-green\">COMMITTED!</div>\n          <div className=\"text-sm text-gray-400 mt-1\">Waiting for arena to end...</div>\n        </motion.div>\n      )}\n\n      {isEnded && (\n        <div className=\"space-y-3\">\n          <motion.button\n            whileTap={{ scale: 0.95 }}\n            onClick={handleReveal}\n            className=\"w-full py-4 rounded-xl font-display font-bold text-lg tracking-wider btn-neon-green\"\n          >\n            üéØ REVEAL & CLAIM\n          </motion.button>\n          {onShare && (\n            <button\n              onClick={onShare}\n              className=\"w-full py-3 rounded-xl font-bold text-sm glass-card border border-purple-500/20 hover:bg-white/5 transition-all\"\n            >\n              üì§ Share Result\n            </button>\n          )}\n        </div>\n      )}\n    </motion.div>\n  );\n}\n","'use client';\n\nimport { useLivePrices } from '@/hooks/useApi';\n\ninterface PriceChartProps {\n  arenaId?: number;\n  height?: number;\n}\n\nexport function PriceChart({ arenaId, height = 200 }: PriceChartProps) {\n  const { prices, connected } = useLivePrices(arenaId);\n\n  if (prices.length < 2) {\n    return (\n      <div className=\"glass-card rounded-xl p-6 text-center border border-purple-500/10\">\n        <div className=\"text-sm text-gray-500\">\n          {connected ? (\n            <span className=\"animate-neon-pulse\">‚è≥ Waiting for price data...</span>\n          ) : (\n            <span>üîå Connecting to price feed...</span>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  const values = prices.map((p) => parseFloat(p.price));\n  const min = Math.min(...values);\n  const max = Math.max(...values);\n  const range = max - min || 1;\n  const w = 600;\n  const h = height;\n  const pad = 30;\n\n  const points = values.map((v, i) => {\n    const x = pad + (i / (values.length - 1)) * (w - 2 * pad);\n    const y = pad + (1 - (v - min) / range) * (h - 2 * pad);\n    return `${x},${y}`;\n  });\n\n  const lastPrice = values[values.length - 1];\n  const firstPrice = values[0];\n  const change = lastPrice - firstPrice;\n  const isUp = change >= 0;\n  const color = isUp ? '#39ff14' : '#ff1744';\n  const glowColor = isUp ? 'rgba(57,255,20,0.15)' : 'rgba(255,23,68,0.15)';\n\n  return (\n    <div className=\"glass-card rounded-xl p-4 border border-purple-500/10\">\n      <div className=\"flex justify-between items-center mb-3\">\n        <div className=\"flex items-center gap-2\">\n          <span className=\"text-[10px] text-gray-500 uppercase tracking-widest font-display\">PRICE FEED</span>\n          {connected && <span className=\"w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse\" />}\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <span className=\"font-display text-xl font-bold text-white\">${lastPrice.toFixed(2)}</span>\n          <span className={`font-display text-sm font-bold ${isUp ? 'neon-text-green' : 'neon-text-red'}`}>\n            {isUp ? '+' : ''}{change.toFixed(2)}\n          </span>\n        </div>\n      </div>\n      <svg viewBox={`0 0 ${w} ${h}`} className=\"w-full h-auto\">\n        <defs>\n          <linearGradient id=\"chartGrad\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n            <stop offset=\"0%\" stopColor={color} stopOpacity=\"0.3\" />\n            <stop offset=\"100%\" stopColor={color} stopOpacity=\"0\" />\n          </linearGradient>\n          <filter id=\"glow\">\n            <feGaussianBlur stdDeviation=\"3\" result=\"blur\" />\n            <feMerge>\n              <feMergeNode in=\"blur\" />\n              <feMergeNode in=\"SourceGraphic\" />\n            </feMerge>\n          </filter>\n        </defs>\n        {/* Grid lines */}\n        {[0.25, 0.5, 0.75].map((pct) => (\n          <line\n            key={pct}\n            x1={pad} x2={w - pad}\n            y1={pad + pct * (h - 2 * pad)}\n            y2={pad + pct * (h - 2 * pad)}\n            stroke=\"rgba(255,255,255,0.03)\" strokeWidth=\"0.5\"\n          />\n        ))}\n        {/* Fill */}\n        <polygon\n          fill=\"url(#chartGrad)\"\n          points={`${pad},${h - pad} ${points.join(' ')} ${w - pad},${h - pad}`}\n        />\n        {/* Line */}\n        <polyline fill=\"none\" stroke={color} strokeWidth=\"2\" points={points.join(' ')} filter=\"url(#glow)\" />\n        {/* Dot */}\n        <circle\n          cx={parseFloat(points[points.length - 1].split(',')[0])}\n          cy={parseFloat(points[points.length - 1].split(',')[1])}\n          r=\"4\" fill={color}\n        />\n        <circle\n          cx={parseFloat(points[points.length - 1].split(',')[0])}\n          cy={parseFloat(points[points.length - 1].split(',')[1])}\n          r=\"8\" fill={color} opacity=\"0.3\"\n        >\n          <animate attributeName=\"r\" from=\"4\" to=\"12\" dur=\"1.5s\" repeatCount=\"indefinite\" />\n          <animate attributeName=\"opacity\" from=\"0.3\" to=\"0\" dur=\"1.5s\" repeatCount=\"indefinite\" />\n        </circle>\n      </svg>\n      <div className=\"flex justify-between text-[10px] text-gray-600 mt-1 font-display\">\n        <span>#{prices[0].block}</span>\n        <span>{prices.length} pts</span>\n        <span>#{prices[prices.length - 1].block}</span>\n      </div>\n    </div>\n  );\n}\n","'use client';\n\nimport { TIER_CONFIG, type ArenaTier } from '@/types';\nimport { motion } from 'framer-motion';\n\ninterface TierSelectorProps {\n  selected: ArenaTier | 'all';\n  onSelect: (tier: ArenaTier | 'all') => void;\n}\n\nexport function TierSelector({ selected, onSelect }: TierSelectorProps) {\n  return (\n    <div className=\"flex gap-2 overflow-x-auto pb-2 scrollbar-none\">\n      <TierButton\n        active={selected === 'all'}\n        onClick={() => onSelect('all')}\n        label=\"ALL\"\n        color=\"text-white\"\n      />\n      {(Object.entries(TIER_CONFIG) as [ArenaTier, (typeof TIER_CONFIG)[ArenaTier]][]).map(\n        ([tier, cfg]) => (\n          <TierButton\n            key={tier}\n            active={selected === tier}\n            onClick={() => onSelect(tier)}\n            label={cfg.label.toUpperCase()}\n            color={cfg.color}\n          />\n        ),\n      )}\n    </div>\n  );\n}\n\nfunction TierButton({ active, onClick, label, color }: { active: boolean; onClick: () => void; label: string; color: string }) {\n  return (\n    <motion.button\n      whileTap={{ scale: 0.95 }}\n      onClick={onClick}\n      className={`relative px-4 py-2 rounded-full text-xs font-display font-bold whitespace-nowrap tracking-wider transition-all ${\n        active\n          ? `${color} bg-white/10 border border-white/20 shadow-[0_0_10px_rgba(255,255,255,0.1)]`\n          : 'text-gray-600 bg-transparent hover:text-gray-400 hover:bg-white/5'\n      }`}\n    >\n      {label}\n    </motion.button>\n  );\n}\n","'use client';\n\nimport { useEffect, useState } from 'react';\n\nconst EMOJIS = ['üéâ', 'üî•', '‚ö°', 'üèÜ', '‚ú®', 'üíé', 'üéä', 'üí∞'];\n\nexport function Confetti({ active, duration = 3500 }: { active: boolean; duration?: number }) {\n  const [show, setShow] = useState(false);\n\n  useEffect(() => {\n    if (active) {\n      setShow(true);\n      const t = setTimeout(() => setShow(false), duration);\n      return () => clearTimeout(t);\n    }\n  }, [active, duration]);\n\n  if (!show) return null;\n\n  return (\n    <div className=\"fixed inset-0 pointer-events-none z-50 overflow-hidden\">\n      {/* Gold flash */}\n      <div className=\"absolute inset-0 animate-gold-flash\" />\n      {/* Particles */}\n      {Array.from({ length: 50 }).map((_, i) => (\n        <span\n          key={i}\n          className=\"absolute animate-confetti-fall\"\n          style={{\n            left: `${Math.random() * 100}%`,\n            animationDelay: `${Math.random() * 1.2}s`,\n            animationDuration: `${2 + Math.random() * 2}s`,\n            fontSize: `${16 + Math.random() * 16}px`,\n          }}\n        >\n          {EMOJIS[i % EMOJIS.length]}\n        </span>\n      ))}\n    </div>\n  );\n}\n","'use client';\n\nimport { useEffect, useState } from 'react';\n\nexport function FireRain({ active, duration = 3000 }: { active: boolean; duration?: number }) {\n  const [show, setShow] = useState(false);\n\n  useEffect(() => {\n    if (active) {\n      setShow(true);\n      const t = setTimeout(() => setShow(false), duration);\n      return () => clearTimeout(t);\n    }\n  }, [active, duration]);\n\n  if (!show) return null;\n\n  return (\n    <div className=\"fixed inset-0 pointer-events-none z-50 overflow-hidden\">\n      {Array.from({ length: 30 }).map((_, i) => (\n        <span\n          key={i}\n          className=\"absolute animate-fire-rain text-2xl\"\n          style={{\n            left: `${Math.random() * 100}%`,\n            animationDelay: `${Math.random() * 1}s`,\n            animationDuration: `${1.5 + Math.random() * 2}s`,\n          }}\n        >\n          üî•\n        </span>\n      ))}\n    </div>\n  );\n}\n","'use client';\n\nimport { useEffect, useState, type ReactNode } from 'react';\n\ninterface ScreenShakeProps {\n  trigger: number; // increment to trigger\n  children: ReactNode;\n}\n\nexport function ScreenShake({ trigger, children }: ScreenShakeProps) {\n  const [shaking, setShaking] = useState(false);\n\n  useEffect(() => {\n    if (trigger > 0) {\n      setShaking(true);\n      const t = setTimeout(() => setShaking(false), 500);\n      return () => clearTimeout(t);\n    }\n  }, [trigger]);\n\n  return (\n    <div className={shaking ? 'animate-screen-shake' : ''}>{children}</div>\n  );\n}\n","'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useSoundEffects } from '@/hooks/useSoundEffects';\n\ninterface ArenaCountdownProps {\n  blocksRemaining: number;\n  label?: string;\n}\n\nexport function ArenaCountdown({ blocksRemaining, label = 'NEXT ARENA' }: ArenaCountdownProps) {\n  const { playCountdown, playGo } = useSoundEffects();\n  const [flash, setFlash] = useState(false);\n  const isFinal3 = blocksRemaining <= 3 && blocksRemaining > 0;\n  const isGo = blocksRemaining === 0;\n\n  useEffect(() => {\n    if (isFinal3) playCountdown();\n    if (isGo) {\n      playGo();\n      setFlash(true);\n      setTimeout(() => setFlash(false), 300);\n    }\n  }, [blocksRemaining, isFinal3, isGo, playCountdown, playGo]);\n\n  if (isGo) {\n    return (\n      <>\n        {flash && <div className=\"fixed inset-0 bg-white/20 z-50 pointer-events-none animate-[screen-flash_0.3s_ease-out_forwards]\" />}\n        <div className=\"flex items-center gap-2\">\n          <span className=\"font-display text-xl font-black neon-text-green animate-celebration\">GO!</span>\n        </div>\n      </>\n    );\n  }\n\n  if (isFinal3) {\n    return (\n      <div className=\"flex items-center justify-center\">\n        <span\n          key={blocksRemaining}\n          className=\"font-display text-3xl font-black neon-text-gold animate-countdown-slam\"\n        >\n          {blocksRemaining}\n        </span>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex items-center gap-2\">\n      <span className=\"animate-heartbeat text-red-500\">‚ù§Ô∏è</span>\n      <span className=\"text-xs text-gray-400 font-medium\">{label} IN</span>\n      <span className=\"font-display text-sm font-bold neon-text-blue\">{blocksRemaining}</span>\n      <span className=\"text-xs text-gray-500\">blocks</span>\n    </div>\n  );\n}\n","'use client';\n\nimport { useRef, useCallback } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\n\ninterface ShareCardModalProps {\n  arenaId: number;\n  score: number;\n  total: number;\n  streak: number;\n  predictions: boolean[];\n  rank?: number;\n  onClose: () => void;\n}\n\nexport function ShareCardModal({ arenaId, score, total, streak, predictions, rank, onClose }: ShareCardModalProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  const generateImage = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return null;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return null;\n\n    canvas.width = 600;\n    canvas.height = 400;\n\n    // Background\n    const grad = ctx.createLinearGradient(0, 0, 600, 400);\n    grad.addColorStop(0, '#0a0a0f');\n    grad.addColorStop(1, '#1a1a2e');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, 600, 400);\n\n    // Border glow\n    ctx.strokeStyle = '#bf00ff';\n    ctx.lineWidth = 2;\n    ctx.shadowColor = '#bf00ff';\n    ctx.shadowBlur = 20;\n    ctx.strokeRect(10, 10, 580, 380);\n    ctx.shadowBlur = 0;\n\n    // Title\n    ctx.fillStyle = '#ffffff';\n    ctx.font = 'bold 28px Orbitron, monospace';\n    ctx.textAlign = 'center';\n    ctx.fillText('‚ö° BLOCKARENA', 300, 55);\n\n    // Arena info\n    ctx.fillStyle = '#a0a0b0';\n    ctx.font = '16px Inter, sans-serif';\n    ctx.fillText(`Arena #${arenaId}`, 300, 85);\n\n    // Score\n    ctx.fillStyle = '#ffd700';\n    ctx.shadowColor = '#ffd700';\n    ctx.shadowBlur = 15;\n    ctx.font = 'bold 48px Orbitron, monospace';\n    ctx.fillText(`${score}/${total}`, 300, 150);\n    ctx.shadowBlur = 0;\n\n    // Streak\n    if (streak > 0) {\n      ctx.fillStyle = '#ff6600';\n      ctx.font = 'bold 24px Inter, sans-serif';\n      ctx.fillText(`üî• ${streak}x Streak`, 300, 190);\n    }\n\n    // Rank\n    if (rank) {\n      ctx.fillStyle = '#00d4ff';\n      ctx.font = '18px Inter, sans-serif';\n      ctx.fillText(`Rank #${rank}`, 300, 220);\n    }\n\n    // Prediction grid\n    const gridStartX = 300 - (Math.min(predictions.length, 15) * 20) / 2;\n    const gridStartY = 250;\n    const rows = Math.ceil(predictions.length / 15);\n\n    for (let i = 0; i < predictions.length; i++) {\n      const row = Math.floor(i / 15);\n      const col = i % 15;\n      const x = gridStartX + col * 20;\n      const y = gridStartY + row * 20;\n\n      ctx.fillStyle = predictions[i] ? '#39ff14' : '#ff1744';\n      ctx.shadowColor = predictions[i] ? '#39ff14' : '#ff1744';\n      ctx.shadowBlur = 5;\n      ctx.beginPath();\n      ctx.roundRect(x, y, 16, 16, 3);\n      ctx.fill();\n    }\n    ctx.shadowBlur = 0;\n\n    // Footer\n    ctx.fillStyle = '#555';\n    ctx.font = '12px Inter, sans-serif';\n    ctx.fillText('blockarena.gg', 300, 380);\n\n    return canvas.toDataURL('image/png');\n  }, [arenaId, score, total, streak, predictions, rank]);\n\n  const getShareText = () => {\n    const grid = predictions.map(p => p ? 'üü©' : 'üü•').join('');\n    return `BlockArena üèüÔ∏è Arena #${arenaId}\\nScore: ${score}/${total} ${streak > 0 ? `üî• ${streak}x Streak` : ''}\\n${grid}`;\n  };\n\n  const handleDownload = () => {\n    const url = generateImage();\n    if (!url) return;\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `blockarena-${arenaId}.png`;\n    a.click();\n  };\n\n  const handleCopy = async () => {\n    await navigator.clipboard.writeText(getShareText()).catch(() => {});\n  };\n\n  const handleShare = async (platform: string) => {\n    const text = encodeURIComponent(getShareText());\n    const urls: Record<string, string> = {\n      twitter: `https://twitter.com/intent/tweet?text=${text}`,\n      telegram: `https://t.me/share/url?text=${text}`,\n      whatsapp: `https://wa.me/?text=${text}`,\n    };\n    if (urls[platform]) window.open(urls[platform], '_blank');\n  };\n\n  return (\n    <AnimatePresence>\n      <motion.div\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n        className=\"fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4\"\n        onClick={onClose}\n      >\n        <motion.div\n          initial={{ scale: 0.9, y: 20 }}\n          animate={{ scale: 1, y: 0 }}\n          className=\"glass-card rounded-2xl p-6 max-w-lg w-full border border-purple-500/20\"\n          onClick={e => e.stopPropagation()}\n        >\n          <h3 className=\"font-display text-xl font-bold text-center mb-4 neon-text-gold\">SHARE YOUR RESULT</h3>\n\n          <canvas ref={canvasRef} className=\"w-full rounded-lg mb-4 hidden\" />\n\n          {/* Preview */}\n          <div className=\"bg-[var(--bg-primary)] rounded-xl p-4 mb-4 text-center\">\n            <div className=\"font-display text-sm text-gray-400 mb-1\">Arena #{arenaId}</div>\n            <div className=\"font-display text-3xl font-black neon-text-gold mb-2\">{score}/{total}</div>\n            {streak > 0 && <div className=\"text-orange-400 font-bold mb-2\">üî• {streak}x Streak</div>}\n            <div className=\"flex flex-wrap justify-center gap-1 mb-2\">\n              {predictions.map((p, i) => (\n                <div key={i} className={`w-5 h-5 rounded-sm ${p ? 'bg-green-500 shadow-[0_0_5px_rgba(57,255,20,0.5)]' : 'bg-red-500 shadow-[0_0_5px_rgba(255,23,68,0.5)]'}`} />\n              ))}\n            </div>\n          </div>\n\n          {/* Share buttons */}\n          <div className=\"grid grid-cols-2 gap-2 mb-3\">\n            <button onClick={() => handleShare('twitter')} className=\"py-2.5 rounded-lg bg-blue-600 hover:bg-blue-500 font-bold text-sm transition-all active:scale-95\">ùïè Twitter</button>\n            <button onClick={() => handleShare('telegram')} className=\"py-2.5 rounded-lg bg-blue-500 hover:bg-blue-400 font-bold text-sm transition-all active:scale-95\">‚úàÔ∏è Telegram</button>\n            <button onClick={() => handleShare('whatsapp')} className=\"py-2.5 rounded-lg bg-green-600 hover:bg-green-500 font-bold text-sm transition-all active:scale-95\">üí¨ WhatsApp</button>\n            <button onClick={handleCopy} className=\"py-2.5 rounded-lg bg-gray-700 hover:bg-gray-600 font-bold text-sm transition-all active:scale-95\">üìã Copy Text</button>\n          </div>\n          <button onClick={handleDownload} className=\"w-full py-2.5 rounded-lg bg-purple-600 hover:bg-purple-500 font-bold text-sm transition-all active:scale-95\">üì• Download Image</button>\n          <button onClick={onClose} className=\"w-full mt-2 py-2 text-sm text-gray-400 hover:text-white\">Close</button>\n        </motion.div>\n      </motion.div>\n    </AnimatePresence>\n  );\n}\n","'use client';\n\nimport { useState, useEffect } from 'react';\n\nexport function LiveSpectatorBar() {\n  const [viewers, setViewers] = useState(42);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setViewers(v => Math.max(1, v + Math.floor(Math.random() * 7) - 3));\n    }, 5000);\n    return () => clearInterval(interval);\n  }, []);\n\n  return (\n    <div className=\"flex items-center gap-1.5 text-xs text-gray-400\">\n      <span className=\"w-1.5 h-1.5 rounded-full bg-red-500 animate-pulse\" />\n      <span>üëÄ {viewers}</span>\n    </div>\n  );\n}\n","'use client';\n\nimport { useEffect, useState, useRef } from 'react';\n\ninterface MiniBlock {\n  number: string;\n  hash: string;\n  timestamp: string;\n  payload_id?: string;\n  index?: number;\n  transactions?: unknown[];\n}\n\n/**\n * MegaETH real-time mini-block subscription hook.\n *\n * Uses `eth_subscribe(\"miniBlocks\")` for real-time data (MegaETH-specific).\n * Falls back to `newHeads` if miniBlocks subscription fails.\n *\n * Implements WebSocket keepalive: sends eth_chainId every 30 seconds\n * to prevent disconnection (required by MegaETH WS endpoints).\n */\nexport function useMiniBlocks() {\n  const [latestBlock, setLatestBlock] = useState<MiniBlock | null>(null);\n  const [blockNumber, setBlockNumber] = useState<bigint>(0n);\n  const wsRef = useRef<WebSocket | null>(null);\n  const keepaliveRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  useEffect(() => {\n    const connect = () => {\n      const ws = new WebSocket('wss://carrot.megaeth.com/ws');\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        // Subscribe to miniBlocks (MegaETH-specific, higher resolution than newHeads)\n        ws.send(\n          JSON.stringify({\n            jsonrpc: '2.0',\n            method: 'eth_subscribe',\n            params: ['miniBlocks'],\n            id: 1,\n          })\n        );\n\n        // MegaETH WebSocket keepalive: send eth_chainId every 30 seconds\n        // Required to prevent disconnection per MegaETH WS guidelines\n        keepaliveRef.current = setInterval(() => {\n          if (ws.readyState === WebSocket.OPEN) {\n            ws.send(\n              JSON.stringify({\n                jsonrpc: '2.0',\n                method: 'eth_chainId',\n                params: [],\n                id: Date.now(),\n              })\n            );\n          }\n        }, 30_000);\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n\n          // Handle subscription error (miniBlocks not supported) ‚Äî fall back to newHeads\n          if (data.id === 1 && data.error) {\n            ws.send(\n              JSON.stringify({\n                jsonrpc: '2.0',\n                method: 'eth_subscribe',\n                params: ['newHeads'],\n                id: 2,\n              })\n            );\n            return;\n          }\n\n          if (data.method === 'eth_subscription' && data.params?.result) {\n            const block = data.params.result;\n            setLatestBlock(block);\n            if (block.number) {\n              setBlockNumber(BigInt(block.number));\n            } else if (block.block_number) {\n              // miniBlocks schema uses block_number\n              setBlockNumber(BigInt(block.block_number));\n            }\n          }\n        } catch {\n          // ignore parse errors\n        }\n      };\n\n      ws.onclose = () => {\n        if (keepaliveRef.current) {\n          clearInterval(keepaliveRef.current);\n          keepaliveRef.current = null;\n        }\n        setTimeout(connect, 1000);\n      };\n\n      ws.onerror = () => {\n        ws.close();\n      };\n    };\n\n    connect();\n    return () => {\n      if (keepaliveRef.current) {\n        clearInterval(keepaliveRef.current);\n        keepaliveRef.current = null;\n      }\n      wsRef.current?.close();\n    };\n  }, []);\n\n  return { latestBlock, blockNumber };\n}\n","'use client';\n\nimport { useRef, useCallback, type TouchEvent } from 'react';\n\nexport function useSwipe(onLeft: () => void, onRight: () => void, threshold = 50) {\n  const startX = useRef(0);\n\n  const onTouchStart = useCallback((e: TouchEvent) => {\n    startX.current = e.touches[0].clientX;\n  }, []);\n\n  const onTouchEnd = useCallback(\n    (e: TouchEvent) => {\n      const diff = e.changedTouches[0].clientX - startX.current;\n      if (Math.abs(diff) > threshold) {\n        if (diff > 0) onRight();\n        else onLeft();\n      }\n    },\n    [onLeft, onRight, threshold],\n  );\n\n  return { onTouchStart, onTouchEnd };\n}\n","'use client';\n\nimport { ConnectWallet } from '@/components/ConnectWallet';\nimport { ArenaCard, getTierFromIndex } from '@/components/ArenaCard';\nimport { PredictionPanel } from '@/components/PredictionPanel';\nimport { PriceChart } from '@/components/PriceChart';\nimport { TierSelector } from '@/components/TierSelector';\nimport { PlayerProfileCard } from '@/components/GodStreak';\nimport { Confetti } from '@/components/Confetti';\nimport { FireRain } from '@/components/FireRain';\nimport { ScreenShake } from '@/components/ScreenShake';\nimport { ArenaCountdown } from '@/components/ArenaCountdown';\nimport { ShareCardModal } from '@/components/ShareCard';\nimport { LiveSpectatorBar } from '@/components/LiveSpectatorBar';\nimport { useMiniBlocks } from '@/hooks/useMiniBlocks';\nimport { useArenaCount, useArena, useGodStreak } from '@/hooks/useArena';\nimport { useWallet } from '@/hooks/useWallet';\nimport { useSwipe } from '@/hooks/useSwipe';\nimport { useState, useMemo, useCallback } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport type { ArenaTier } from '@/types';\nimport Link from 'next/link';\n\nexport default function Home() {\n  const { blockNumber } = useMiniBlocks();\n  const { data: arenaCount } = useArenaCount();\n  const { isConnected, address } = useWallet();\n  const { data: godStreak } = useGodStreak(address as `0x${string}` | undefined);\n  const [selectedArena, setSelectedArena] = useState<bigint | null>(null);\n  const [tierFilter, setTierFilter] = useState<ArenaTier | 'all'>('all');\n  const [confettiTrigger, setConfettiTrigger] = useState(false);\n  const [fireRainTrigger, setFireRainTrigger] = useState(false);\n  const [shakeTrigger, setShakeTrigger] = useState(0);\n  const [showShare, setShowShare] = useState(false);\n\n  const count = arenaCount ? Number(arenaCount) : 0;\n  const arenaIds = useMemo(\n    () => Array.from({ length: count }, (_, i) => BigInt(count - 1 - i)),\n    [count],\n  );\n\n  const swipeToNext = useCallback(() => {\n    if (arenaIds.length === 0) return;\n    setSelectedArena((prev) => {\n      if (prev === null) return arenaIds[0];\n      const idx = arenaIds.indexOf(prev);\n      return arenaIds[Math.min(idx + 1, arenaIds.length - 1)];\n    });\n  }, [arenaIds]);\n\n  const swipeToPrev = useCallback(() => {\n    if (arenaIds.length === 0) return;\n    setSelectedArena((prev) => {\n      if (prev === null) return arenaIds[0];\n      const idx = arenaIds.indexOf(prev);\n      return arenaIds[Math.max(idx - 1, 0)];\n    });\n  }, [arenaIds]);\n\n  const swipeHandlers = useSwipe(swipeToNext, swipeToPrev);\n  const streak = godStreak ? Number(godStreak) : 0;\n\n  return (\n    <ScreenShake trigger={shakeTrigger}>\n      <Confetti active={confettiTrigger} />\n      <FireRain active={fireRainTrigger} />\n\n      {/* Persistent top bar */}\n      <div className=\"sticky top-0 z-30 glass-card border-b border-white/5\">\n        <div className=\"max-w-4xl mx-auto px-4 py-2 flex items-center justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <span className=\"font-display text-lg font-bold neon-text-purple\">‚ö° BLOCKARENA</span>\n            {streak > 0 && (\n              <span className=\"text-xs font-bold px-2 py-0.5 rounded-full bg-orange-500/20 text-orange-400 border border-orange-500/30\">\n                üî• {streak}x\n              </span>\n            )}\n          </div>\n          <div className=\"flex items-center gap-3\">\n            <LiveSpectatorBar />\n            <ConnectWallet />\n          </div>\n        </div>\n        {/* Next arena countdown - always visible */}\n        {selectedArena !== null && (\n          <SelectedArenaCountdown arenaId={selectedArena} currentBlock={blockNumber} />\n        )}\n      </div>\n\n      <main className=\"max-w-4xl mx-auto px-4 py-4 sm:py-6\" {...swipeHandlers}>\n        {/* Daily Challenge Banner */}\n        <motion.div\n          initial={{ opacity: 0, y: -10 }}\n          animate={{ opacity: 1, y: 0 }}\n          className=\"mb-4 p-3 rounded-xl bg-gradient-to-r from-purple-900/40 to-blue-900/40 border border-purple-500/20 flex items-center justify-between\"\n        >\n          <div className=\"flex items-center gap-2\">\n            <span className=\"text-lg\">üéØ</span>\n            <div>\n              <div className=\"text-sm font-bold text-white\">Daily Challenge</div>\n              <div className=\"text-xs text-gray-400\">Play 5 arenas for 2x multiplier</div>\n            </div>\n          </div>\n          <div className=\"flex gap-1\">\n            {[1,2,3,4,5].map(i => (\n              <div key={i} className={`w-3 h-3 rounded-full ${i <= 2 ? 'bg-purple-500' : 'bg-gray-700'}`} />\n            ))}\n          </div>\n        </motion.div>\n\n        {/* Desktop nav */}\n        <div className=\"hidden md:flex gap-2 mb-6\">\n          {[\n            { href: '/', icon: '‚ö°', label: 'Arena', active: true },\n            { href: '/history', icon: 'üìä', label: 'Stats' },\n            { href: '/leaderboard', icon: 'üèÜ', label: 'Leaderboard' },\n            { href: '/gallery', icon: 'üñºÔ∏è', label: 'Gallery' },\n            { href: '/tournament', icon: '‚öîÔ∏è', label: 'Tournament' },\n          ].map(item => (\n            <Link\n              key={item.href}\n              href={item.href}\n              className={`px-4 py-2 rounded-lg text-sm font-medium transition-all ${\n                item.active\n                  ? 'bg-purple-600/30 text-purple-300 border border-purple-500/30'\n                  : 'text-gray-400 hover:text-white hover:bg-white/5'\n              }`}\n            >\n              {item.icon} {item.label}\n            </Link>\n          ))}\n        </div>\n\n        {/* Live Block Counter */}\n        <motion.div\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          className=\"mb-4 p-3 glass-card rounded-xl flex justify-between items-center\"\n        >\n          <span className=\"text-gray-400 text-sm\">Current Block</span>\n          <span className=\"font-display text-lg neon-text-green\">#{blockNumber.toString()}</span>\n        </motion.div>\n\n        {/* Live Price Chart */}\n        <AnimatePresence>\n          {selectedArena !== null && (\n            <motion.div\n              initial={{ opacity: 0, height: 0 }}\n              animate={{ opacity: 1, height: 'auto' }}\n              exit={{ opacity: 0, height: 0 }}\n              className=\"mb-4\"\n            >\n              <PriceChart arenaId={Number(selectedArena)} />\n            </motion.div>\n          )}\n        </AnimatePresence>\n\n        {/* Profile Card */}\n        {isConnected && address && (\n          <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} className=\"mb-4\">\n            <PlayerProfileCard address={address} streak={streak} bestStreak={streak} wins={0} losses={0} />\n          </motion.div>\n        )}\n\n        {/* Tier Filter */}\n        <div className=\"mb-4\">\n          <TierSelector selected={tierFilter} onSelect={setTierFilter} />\n        </div>\n\n        {/* Arena List */}\n        <div className=\"space-y-3 mb-6\">\n          <h2 className=\"text-lg font-bold font-display text-white/90\">LIVE ARENAS</h2>\n          {count === 0 && (\n            <div className=\"text-center py-12\">\n              <div className=\"text-4xl mb-3\">üèüÔ∏è</div>\n              <p className=\"text-gray-500 text-sm\">No arenas yet. Deploy the contract and create one!</p>\n            </div>\n          )}\n          <AnimatePresence>\n            {arenaIds.map((id, i) => (\n              <motion.div\n                key={id.toString()}\n                initial={{ opacity: 0, y: 20 }}\n                animate={{ opacity: 1, y: 0 }}\n                transition={{ delay: i * 0.05 }}\n              >\n                <FilteredArenaCard\n                  arenaId={id}\n                  currentBlock={blockNumber}\n                  tierFilter={tierFilter}\n                  onClick={() => setSelectedArena(id)}\n                  selected={selectedArena === id}\n                />\n              </motion.div>\n            ))}\n          </AnimatePresence>\n        </div>\n\n        {/* Prediction Panel */}\n        <AnimatePresence>\n          {selectedArena !== null && isConnected && (\n            <motion.div\n              initial={{ opacity: 0, y: 30 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: 30 }}\n            >\n              <SelectedArenaPrediction\n                arenaId={selectedArena}\n                currentBlock={blockNumber}\n                onWin={() => { setConfettiTrigger(true); setShakeTrigger(s => s+1); setTimeout(() => setConfettiTrigger(false), 100); }}\n                onStreak={() => { setFireRainTrigger(true); setTimeout(() => setFireRainTrigger(false), 100); }}\n                onShare={() => setShowShare(true)}\n              />\n            </motion.div>\n          )}\n        </AnimatePresence>\n\n        {/* Play Again CTA */}\n        {!selectedArena && count > 0 && (\n          <motion.button\n            initial={{ scale: 0.9 }}\n            animate={{ scale: 1 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={() => arenaIds[0] && setSelectedArena(arenaIds[0])}\n            className=\"w-full py-4 rounded-xl btn-neon-green text-xl font-display tracking-wider mb-6\"\n          >\n            ‚ö° PLAY NOW\n          </motion.button>\n        )}\n      </main>\n\n      {/* Share Card Modal */}\n      {showShare && (\n        <ShareCardModal\n          arenaId={selectedArena ? Number(selectedArena) : 0}\n          score={142}\n          total={150}\n          streak={streak}\n          predictions={Array.from({length: 10}, () => Math.random() > 0.3)}\n          onClose={() => setShowShare(false)}\n        />\n      )}\n    </ScreenShake>\n  );\n}\n\nfunction FilteredArenaCard({\n  arenaId, currentBlock, tierFilter, onClick, selected,\n}: {\n  arenaId: bigint; currentBlock: bigint; tierFilter: ArenaTier | 'all'; onClick: () => void; selected: boolean;\n}) {\n  const { data: arena } = useArena(arenaId);\n  if (!arena) return null;\n  if (tierFilter !== 'all' && getTierFromIndex(Number(arena.tier)) !== tierFilter) return null;\n  return (\n    <div onClick={onClick} className={`cursor-pointer transition-all ${selected ? 'ring-2 ring-purple-500/50 rounded-xl' : ''}`}>\n      <ArenaCard arenaId={arenaId} currentBlock={currentBlock} />\n    </div>\n  );\n}\n\nfunction SelectedArenaCountdown({ arenaId, currentBlock }: { arenaId: bigint; currentBlock: bigint }) {\n  const { data: arena } = useArena(arenaId);\n  if (!arena) return null;\n  const startBlock = BigInt(arena.startBlock);\n  const endBlock = BigInt(arena.endBlock);\n  const isActive = currentBlock >= startBlock && currentBlock <= endBlock;\n  const blocksLeft = isActive ? Number(endBlock - currentBlock) : Number(startBlock - currentBlock);\n  const isUpcoming = currentBlock < startBlock;\n\n  if (!isActive && !isUpcoming) return null;\n\n  return (\n    <div className=\"px-4 py-1.5 flex items-center justify-center gap-2 text-sm\">\n      {isUpcoming ? (\n        <ArenaCountdown blocksRemaining={blocksLeft} label=\"NEXT ARENA\" />\n      ) : (\n        <>\n          <span className=\"w-2 h-2 rounded-full bg-red-500 animate-pulse\" />\n          <span className=\"text-red-400 font-bold font-display text-xs\">LIVE</span>\n          <span className=\"text-gray-400 mx-1\">¬∑</span>\n          <span className=\"font-display text-xs neon-text-blue\">{blocksLeft} blocks left</span>\n        </>\n      )}\n    </div>\n  );\n}\n\nfunction SelectedArenaPrediction({\n  arenaId, currentBlock, onWin, onStreak, onShare,\n}: {\n  arenaId: bigint; currentBlock: bigint; onWin: () => void; onStreak: () => void; onShare: () => void;\n}) {\n  const { data: arena } = useArena(arenaId);\n  if (!arena) return null;\n  const startBlock = BigInt(arena.startBlock);\n  const endBlock = BigInt(arena.endBlock);\n  const isActive = currentBlock >= startBlock && currentBlock <= endBlock;\n  const isEnded = currentBlock > endBlock && !arena.finalized;\n  const numTicks = Number(endBlock - startBlock);\n\n  return (\n    <PredictionPanel\n      arenaId={arenaId}\n      numTicks={numTicks}\n      isActive={isActive}\n      isEnded={isEnded}\n      onWin={onWin}\n      onStreak={onStreak}\n      onShare={onShare}\n    />\n  );\n}\n","export const DIAMOND_ADDRESS = '0x0000000000000000000000000000000000000000' as const; // TODO: deploy and fill\n\n// Backwards compat alias\nexport const ARENA_ENGINE_ADDRESS = DIAMOND_ADDRESS;\n\nexport const ARENA_ENGINE_ABI = [\n  // ‚îÄ‚îÄ‚îÄ ArenaFacet ‚îÄ‚îÄ‚îÄ\n  {\n    type: 'function',\n    name: 'createArena',\n    inputs: [\n      { name: 'tier', type: 'uint8' },\n      { name: 'duration', type: 'uint40' },\n    ],\n    outputs: [{ name: 'arenaId', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'joinArena',\n    inputs: [{ name: 'arenaId', type: 'uint256' }],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'commitPrediction',\n    inputs: [\n      { name: 'arenaId', type: 'uint256' },\n      { name: 'commitHash', type: 'bytes32' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'revealPrediction',\n    inputs: [\n      { name: 'arenaId', type: 'uint256' },\n      { name: 'predWords', type: 'uint256[]' },\n      { name: 'salt', type: 'bytes32' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'finalizeArena',\n    inputs: [\n      { name: 'arenaId', type: 'uint256' },\n      { name: 'players', type: 'address[]' },\n      { name: 'predWordsList', type: 'uint256[][]' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'resetArena',\n    inputs: [\n      { name: 'arenaId', type: 'uint256' },\n      { name: 'duration', type: 'uint40' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'setMinWalletBalance',\n    inputs: [{ name: '_minBalance', type: 'uint256' }],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'minWalletBalance',\n    inputs: [],\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'nextArenaId',\n    inputs: [],\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getArena',\n    inputs: [{ name: 'id', type: 'uint256' }],\n    outputs: [\n      {\n        name: '',\n        type: 'tuple',\n        components: [\n          { name: 'startBlock', type: 'uint40' },\n          { name: 'endBlock', type: 'uint40' },\n          { name: 'pot', type: 'uint128' },\n          { name: 'playerCount', type: 'uint16' },\n          { name: 'tier', type: 'uint8' },\n          { name: 'finalized', type: 'bool' },\n          { name: 'tournamentId', type: 'uint256' },\n        ],\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'arenaEpoch',\n    inputs: [{ name: 'id', type: 'uint256' }],\n    outputs: [{ name: '', type: 'uint32' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getPlayerState',\n    inputs: [\n      { name: 'id', type: 'uint256' },\n      { name: 'p', type: 'address' },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'tuple',\n        components: [\n          { name: 'commitHash', type: 'bytes32' },\n          { name: 'revealed', type: 'bool' },\n          { name: 'score', type: 'uint16' },\n        ],\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getPriceTape',\n    inputs: [{ name: 'id', type: 'uint256' }],\n    outputs: [{ name: '', type: 'uint256[]' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getOracleState',\n    inputs: [{ name: 'id', type: 'uint256' }],\n    outputs: [\n      {\n        name: '',\n        type: 'tuple',\n        components: [\n          { name: 'nextBlock', type: 'uint40' },\n          { name: 'ticksRecorded', type: 'uint40' },\n          { name: 'lastPrice', type: 'int256' },\n        ],\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'godStreak',\n    inputs: [{ name: 'player', type: 'address' }],\n    outputs: [{ name: '', type: 'uint16' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getEntryFee',\n    inputs: [{ name: 'tier', type: 'uint8' }],\n    outputs: [{ name: '', type: 'uint128' }],\n    stateMutability: 'pure',\n  },\n  {\n    type: 'function',\n    name: 'getRakeBps',\n    inputs: [{ name: 'tier', type: 'uint8' }],\n    outputs: [{ name: '', type: 'uint16' }],\n    stateMutability: 'pure',\n  },\n  {\n    type: 'function',\n    name: 'computeCommitHash',\n    inputs: [\n      { name: 'arenaId', type: 'uint256' },\n      { name: 'player', type: 'address' },\n      { name: 'salt', type: 'bytes32' },\n      { name: 'predWords', type: 'uint256[]' },\n    ],\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'pure',\n  },\n  // ‚îÄ‚îÄ‚îÄ OracleFacet ‚îÄ‚îÄ‚îÄ\n  {\n    type: 'function',\n    name: 'setOracle',\n    inputs: [{ name: 'priceFeed', type: 'address' }],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'oracle',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'recordTick',\n    inputs: [{ name: 'arenaId', type: 'uint256' }],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'recordTicks',\n    inputs: [\n      { name: 'arenaId', type: 'uint256' },\n      { name: 'maxTicks', type: 'uint40' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  // ‚îÄ‚îÄ‚îÄ TournamentFacet ‚îÄ‚îÄ‚îÄ\n  {\n    type: 'function',\n    name: 'createTournament',\n    inputs: [\n      { name: 'tier', type: 'uint8' },\n      { name: 'roundCount', type: 'uint8' },\n      { name: 'arenasPerRound', type: 'uint8' },\n    ],\n    outputs: [{ name: 'id', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'addArenaToTournament',\n    inputs: [\n      { name: 'tid', type: 'uint256' },\n      { name: 'arenaId', type: 'uint256' },\n      { name: 'round', type: 'uint8' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'advanceTournamentRound',\n    inputs: [{ name: 'tid', type: 'uint256' }],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'finalizeTournament',\n    inputs: [\n      { name: 'tid', type: 'uint256' },\n      { name: 'winners', type: 'address[]' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'depositTournamentPot',\n    inputs: [{ name: 'tid', type: 'uint256' }],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'nextTournamentId',\n    inputs: [],\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getTournament',\n    inputs: [{ name: 'id', type: 'uint256' }],\n    outputs: [\n      {\n        name: '',\n        type: 'tuple',\n        components: [\n          { name: 'tier', type: 'uint8' },\n          { name: 'roundCount', type: 'uint8' },\n          { name: 'arenasPerRound', type: 'uint8' },\n          { name: 'currentRound', type: 'uint8' },\n          { name: 'finalized', type: 'bool' },\n          { name: 'pot', type: 'uint128' },\n          { name: 'creator', type: 'address' },\n        ],\n      },\n    ],\n    stateMutability: 'view',\n  },\n  // ‚îÄ‚îÄ‚îÄ FeeFacet ‚îÄ‚îÄ‚îÄ\n  {\n    type: 'function',\n    name: 'setReferrer',\n    inputs: [{ name: '_ref', type: 'address' }],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'withdrawReferralEarnings',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'withdrawTreasury',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'treasuryBalance',\n    inputs: [],\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'referrer',\n    inputs: [{ name: 'player', type: 'address' }],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'referrerBalance',\n    inputs: [{ name: 'player', type: 'address' }],\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'setHighlightsNFT',\n    inputs: [{ name: '_nft', type: 'address' }],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'highlightsNFT',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n  // ‚îÄ‚îÄ‚îÄ StreakFacet ‚îÄ‚îÄ‚îÄ\n  {\n    type: 'function',\n    name: 'getGodStreak',\n    inputs: [{ name: 'player', type: 'address' }],\n    outputs: [{ name: '', type: 'uint16' }],\n    stateMutability: 'view',\n  },\n  // ‚îÄ‚îÄ‚îÄ EmergencyFacet ‚îÄ‚îÄ‚îÄ\n  {\n    type: 'function',\n    name: 'pause',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'unpause',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'paused',\n    inputs: [],\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'emergencyWithdraw',\n    inputs: [\n      { name: 'arenaId', type: 'uint256' },\n      { name: 'players', type: 'address[]' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  // ‚îÄ‚îÄ‚îÄ OwnershipFacet ‚îÄ‚îÄ‚îÄ\n  {\n    type: 'function',\n    name: 'transferOwnership',\n    inputs: [{ name: '_newOwner', type: 'address' }],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'acceptOwnership',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'owner',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'pendingOwner',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n  // ‚îÄ‚îÄ‚îÄ Events ‚îÄ‚îÄ‚îÄ\n  {\n    type: 'event',\n    name: 'ArenaCreated',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'tier', type: 'uint8', indexed: false },\n      { name: 'entryFee', type: 'uint128', indexed: false },\n      { name: 'startBlock', type: 'uint40', indexed: false },\n      { name: 'endBlock', type: 'uint40', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'PlayerJoined',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'player', type: 'address', indexed: true },\n      { name: 'ref', type: 'address', indexed: true },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'PredictionCommitted',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'player', type: 'address', indexed: true },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'PredictionRevealed',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'player', type: 'address', indexed: true },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'ArenaFinalized',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'winnerCount', type: 'uint256', indexed: false },\n      { name: 'bestScore', type: 'uint16', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'PotDistributed',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'winner', type: 'address', indexed: true },\n      { name: 'amount', type: 'uint256', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'GodStreakUpdate',\n    inputs: [\n      { name: 'player', type: 'address', indexed: true },\n      { name: 'streak', type: 'uint16', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'BotDetected',\n    inputs: [\n      { name: 'player', type: 'address', indexed: false },\n      { name: 'reason', type: 'string', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'ReferralPaid',\n    inputs: [\n      { name: 'ref', type: 'address', indexed: true },\n      { name: 'player', type: 'address', indexed: true },\n      { name: 'amount', type: 'uint256', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'ArenaReset',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'newEpoch', type: 'uint32', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'OracleSet',\n    inputs: [{ name: 'oracle', type: 'address', indexed: true }],\n  },\n  {\n    type: 'event',\n    name: 'TicksRecorded',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'count', type: 'uint40', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'TournamentCreated',\n    inputs: [\n      { name: 'tournamentId', type: 'uint256', indexed: true },\n      { name: 'tier', type: 'uint8', indexed: false },\n      { name: 'roundCount', type: 'uint8', indexed: false },\n      { name: 'arenasPerRound', type: 'uint8', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'TournamentArenaAdded',\n    inputs: [\n      { name: 'tournamentId', type: 'uint256', indexed: true },\n      { name: 'round', type: 'uint8', indexed: false },\n      { name: 'arenaId', type: 'uint256', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'TournamentFinalized',\n    inputs: [{ name: 'tournamentId', type: 'uint256', indexed: true }],\n  },\n  {\n    type: 'event',\n    name: 'TournamentPlayerQualified',\n    inputs: [\n      { name: 'tournamentId', type: 'uint256', indexed: true },\n      { name: 'round', type: 'uint8', indexed: false },\n      { name: 'player', type: 'address', indexed: true },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'ReferrerSet',\n    inputs: [\n      { name: 'player', type: 'address', indexed: true },\n      { name: 'ref', type: 'address', indexed: true },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'TreasuryWithdrawn',\n    inputs: [\n      { name: 'to', type: 'address', indexed: true },\n      { name: 'amount', type: 'uint256', indexed: false },\n    ],\n  },\n  {\n    type: 'event',\n    name: 'Paused',\n    inputs: [],\n  },\n  {\n    type: 'event',\n    name: 'Unpaused',\n    inputs: [],\n  },\n  {\n    type: 'event',\n    name: 'EmergencyWithdraw',\n    inputs: [\n      { name: 'arenaId', type: 'uint256', indexed: true },\n      { name: 'player', type: 'address', indexed: true },\n      { name: 'amount', type: 'uint256', indexed: false },\n    ],\n  },\n] as const;\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CommitmentToVersionedHashErrorType,\n  commitmentToVersionedHash,\n} from './commitmentToVersionedHash.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentsToVersionedHashesParameters<\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\n    | readonly Uint8Array[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Commitments from blobs. */\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hashes. */\n  version?: number | undefined\n}\n\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type CommitmentsToVersionedHashesErrorType =\n  | CommitmentToVersionedHashErrorType\n  | ErrorType\n\n/**\n * Transform a list of commitments to their versioned hashes.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentsToVersionedHashes,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\n * ```\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\n  to extends To =\n    | (commitments extends readonly Hex[] ? 'hex' : never)\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\n): CommitmentsToVersionedHashesReturnType<to> {\n  const { commitments, version } = parameters\n\n  const to =\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\n\n  const hashes: Uint8Array[] | Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash({\n        commitment,\n        to,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n","import {\n  ChainMismatchError,\n  type ChainMismatchErrorType,\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n} from '../../errors/chain.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nexport type AssertCurrentChainParameters = {\n  chain?: Chain | undefined\n  currentChainId: number\n}\n\nexport type AssertCurrentChainErrorType =\n  | ChainNotFoundErrorType\n  | ChainMismatchErrorType\n  | ErrorType\n\nexport function assertCurrentChain({\n  chain,\n  currentChainId,\n}: AssertCurrentChainParameters): void {\n  if (!chain) throw new ChainNotFoundError()\n  if (currentChainId !== chain.id)\n    throw new ChainMismatchError({ chain, currentChainId })\n}\n","import type { Abi } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n} from '../../types/contract.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\n\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type ReadContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = UnionEvaluate<\n  Pick<\n    CallParameters,\n    | 'account'\n    | 'authorizationList'\n    | 'blockNumber'\n    | 'blockOverrides'\n    | 'blockTag'\n    | 'factory'\n    | 'factoryData'\n    | 'stateOverride'\n  >\n> &\n  ContractFunctionParameters<abi, 'pure' | 'view', functionName, args, boolean>\n\nexport type ReadContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ContractFunctionReturnType<abi, 'pure' | 'view', functionName, args>\n\nexport type ReadContractErrorType = GetContractErrorReturnType<\n  CallErrorType | EncodeFunctionDataErrorType | DecodeFunctionResultErrorType\n>\n\n/**\n * Calls a read-only function on a contract, and returns the response.\n *\n * - Docs: https://viem.sh/docs/contract/readContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_reading-contracts\n *\n * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link ReadContractParameters}\n * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { readContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await readContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n *   functionName: 'balanceOf',\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // 424122n\n */\nexport async function readContract<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(\n  client: Client<Transport, chain>,\n  parameters: ReadContractParameters<abi, functionName, args>,\n): Promise<ReadContractReturnType<abi, functionName, args>> {\n  const { abi, address, args, functionName, ...rest } =\n    parameters as ReadContractParameters\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const { data } = await getAction(\n      client,\n      call,\n      'call',\n    )({\n      ...(rest as CallParameters),\n      data: calldata,\n      to: address!,\n    })\n    return decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    }) as ReadContractReturnType<abi, functionName>\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/readContract',\n      functionName,\n    })\n  }\n}\n","import type { Address } from 'abitype'\n\nimport { publicKeyToAddress } from '../../accounts/utils/publicKeyToAddress.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { recoverPublicKey } from './recoverPublicKey.js'\n\nexport type RecoverAddressParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverAddressReturnType = Address\n\nexport type RecoverAddressErrorType = ErrorType\n\nexport async function recoverAddress({\n  hash,\n  signature,\n}: RecoverAddressParameters): Promise<RecoverAddressReturnType> {\n  return publicKeyToAddress(await recoverPublicKey({ hash, signature }))\n}\n","import {\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n} from '../../index.js'\nimport type {\n  TransactionRequestGeneric,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n} from '../../types/transaction.js'\nimport type { Assign, ExactPartial, IsNever, OneOf } from '../../types/utils.js'\n\nexport type GetTransactionType<\n  transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  > = TransactionSerializableGeneric,\n  result =\n    | (transaction extends LegacyProperties ? 'legacy' : never)\n    | (transaction extends EIP1559Properties ? 'eip1559' : never)\n    | (transaction extends EIP2930Properties ? 'eip2930' : never)\n    | (transaction extends EIP4844Properties ? 'eip4844' : never)\n    | (transaction extends EIP7702Properties ? 'eip7702' : never)\n    | (transaction['type'] extends TransactionSerializableGeneric['type']\n        ? Extract<transaction['type'], string>\n        : never),\n> = IsNever<keyof transaction> extends true\n  ? string\n  : IsNever<result> extends false\n    ? result\n    : string\n\nexport type GetTransactionTypeErrorType =\n  | InvalidSerializableTransactionErrorType\n  | ErrorType\n\nexport function getTransactionType<\n  const transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  >,\n>(transaction: transaction): GetTransactionType<transaction> {\n  if (transaction.type)\n    return transaction.type as GetTransactionType<transaction>\n\n  if (typeof transaction.authorizationList !== 'undefined')\n    return 'eip7702' as any\n\n  if (\n    typeof transaction.blobs !== 'undefined' ||\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\n    typeof transaction.sidecars !== 'undefined'\n  )\n    return 'eip4844' as any\n\n  if (\n    typeof transaction.maxFeePerGas !== 'undefined' ||\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  ) {\n    return 'eip1559' as any\n  }\n\n  if (typeof transaction.gasPrice !== 'undefined') {\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\n    return 'legacy' as any\n  }\n\n  throw new InvalidSerializableTransactionError({ transaction })\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype BaseProperties = {\n  accessList?: undefined\n  authorizationList?: undefined\n  blobs?: undefined\n  blobVersionedHashes?: undefined\n  gasPrice?: undefined\n  maxFeePerBlobGas?: undefined\n  maxFeePerGas?: undefined\n  maxPriorityFeePerGas?: undefined\n  sidecars?: undefined\n}\n\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\ntype EIP1559Properties = Assign<\n  BaseProperties,\n  OneOf<\n    | {\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\n      }\n    | {\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\n      },\n    FeeValuesEIP1559\n  > & {\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\n  }\n>\ntype EIP2930Properties = Assign<\n  ExactPartial<LegacyProperties>,\n  {\n    accessList: TransactionSerializableEIP2930['accessList']\n  }\n>\ntype EIP4844Properties = Assign<\n  ExactPartial<EIP1559Properties>,\n  ExactPartial<FeeValuesEIP4844> &\n    OneOf<\n      | {\n          blobs: TransactionSerializableEIP4844['blobs']\n        }\n      | {\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\n        }\n      | {\n          sidecars: TransactionSerializableEIP4844['sidecars']\n        },\n      TransactionSerializableEIP4844\n    >\n>\ntype EIP7702Properties = Assign<\n  ExactPartial<EIP1559Properties>,\n  {\n    authorizationList: TransactionSerializableEIP7702['authorizationList']\n  }\n>\n","import {\n  type DefaultError,\n  type MutateFunction,\n  type QueryKey,\n  useInfiniteQuery as tanstack_useInfiniteQuery,\n  useQuery as tanstack_useQuery,\n  type UseInfiniteQueryOptions,\n  type UseInfiniteQueryResult,\n  type UseMutationOptions,\n  type UseMutationResult,\n  type UseQueryOptions,\n  type UseQueryResult,\n  useMutation,\n} from '@tanstack/react-query'\nimport type {\n  Compute,\n  ExactPartial,\n  Omit,\n  UnionStrictOmit,\n} from '@wagmi/core/internal'\nimport { hashFn } from '@wagmi/core/query'\n\nexport { useMutation }\n\nexport type UseMutationParameters<\n  data = unknown,\n  error = Error,\n  variables = void,\n  context = unknown,\n> = Compute<\n  Omit<\n    UseMutationOptions<data, error, Compute<variables>, context>,\n    'mutationFn' | 'mutationKey' | 'throwOnError'\n  >\n>\n\nexport type UseMutationReturnType<\n  data = unknown,\n  error = Error,\n  variables = void,\n  context = unknown,\n  mutate = MutateFunction,\n  mutateAsync = MutateFunction,\n> = Compute<\n  UnionStrictOmit<\n    UseMutationResult<data, error, variables, context>,\n    'mutate' | 'mutateAsync'\n  > & {\n    mutate: mutate\n    mutateAsync: mutateAsync\n  }\n>\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Adding some basic customization.\n// Ideally we don't have this function, but `import('@tanstack/react-query').useQuery` currently has some quirks where it is super hard to\n// pass down the inferred `initialData` type because of it's discriminated overload in the on `useQuery`.\nexport function useQuery<queryFnData, error, data, queryKey extends QueryKey>(\n  parameters: UseQueryParameters<queryFnData, error, data, queryKey> & {\n    queryKey: QueryKey\n  },\n): UseQueryReturnType<data, error> {\n  const result = tanstack_useQuery({\n    ...(parameters as any),\n    queryKeyHashFn: hashFn, // for bigint support\n  }) as UseQueryReturnType<data, error>\n  result.queryKey = parameters.queryKey\n  return result\n}\n\nexport type UseQueryParameters<\n  queryFnData = unknown,\n  error = DefaultError,\n  data = queryFnData,\n  queryKey extends QueryKey = QueryKey,\n> = Compute<\n  ExactPartial<\n    Omit<UseQueryOptions<queryFnData, error, data, queryKey>, 'initialData'>\n  > & {\n    // Fix `initialData` type\n    initialData?:\n      | UseQueryOptions<queryFnData, error, data, queryKey>['initialData']\n      | undefined\n  }\n>\n\nexport type UseQueryReturnType<data = unknown, error = DefaultError> = Compute<\n  UseQueryResult<data, error> & {\n    queryKey: QueryKey\n  }\n>\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Adding some basic customization.\nexport function useInfiniteQuery<\n  queryFnData,\n  error,\n  data,\n  queryKey extends QueryKey,\n>(\n  parameters: UseInfiniteQueryParameters<queryFnData, error, data, queryKey> & {\n    queryKey: QueryKey\n  },\n): UseInfiniteQueryReturnType<data, error> {\n  const result = tanstack_useInfiniteQuery({\n    ...(parameters as any),\n    queryKeyHashFn: hashFn, // for bigint support\n  }) as UseInfiniteQueryReturnType<data, error>\n  result.queryKey = parameters.queryKey\n  return result\n}\n\nexport type UseInfiniteQueryParameters<\n  queryFnData = unknown,\n  error = DefaultError,\n  data = queryFnData,\n  queryData = queryFnData,\n  queryKey extends QueryKey = QueryKey,\n  pageParam = unknown,\n> = Compute<\n  Omit<\n    UseInfiniteQueryOptions<\n      queryFnData,\n      error,\n      data,\n      queryData,\n      queryKey,\n      pageParam\n    >,\n    'initialData'\n  > & {\n    // Fix `initialData` type\n    initialData?:\n      | UseInfiniteQueryOptions<\n          queryFnData,\n          error,\n          data,\n          queryKey\n        >['initialData']\n      | undefined\n  }\n>\n\nexport type UseInfiniteQueryReturnType<\n  data = unknown,\n  error = DefaultError,\n> = UseInfiniteQueryResult<data, error> & {\n  queryKey: QueryKey\n}\n","import type { Config } from '../createConfig.js'\n\nexport type GetChainIdReturnType<config extends Config = Config> =\n  config['chains'][number]['id']\n\n/** https://wagmi.sh/core/api/actions/getChainId */\nexport function getChainId<config extends Config>(\n  config: config,\n): GetChainIdReturnType<config> {\n  return config.state.chainId\n}\n","'use client'\nimport type {\n  Config,\n  ReadContractErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { ConfigParameter, UnionCompute } from '@wagmi/core/internal'\nimport {\n  type ReadContractData,\n  type ReadContractOptions,\n  readContractQueryOptions,\n} from '@wagmi/core/query'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseReadContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UnionCompute<\n  ReadContractOptions<abi, functionName, args, config, selectData> &\n    ConfigParameter<config>\n>\n\nexport type UseReadContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UseQueryReturnType<selectData, ReadContractErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useReadContract */\nexport function useReadContract<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = ResolvedRegister['config'],\n  selectData = ReadContractData<abi, functionName, args>,\n>(\n  parameters: UseReadContractParameters<\n    abi,\n    functionName,\n    args,\n    config,\n    selectData\n  > = {} as any,\n): UseReadContractReturnType<abi, functionName, args, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = readContractQueryOptions(config, {\n    ...(parameters as any),\n    chainId: parameters.chainId ?? chainId,\n  })\n  return useQuery(options) as any\n}\n","'use client'\n\nimport {\n  type Config,\n  type GetChainIdReturnType,\n  getChainId,\n  type ResolvedRegister,\n  watchChainId,\n} from '@wagmi/core'\nimport type { ConfigParameter } from '@wagmi/core/internal'\nimport { useSyncExternalStore } from 'react'\nimport { useConfig } from './useConfig.js'\n\nexport type UseChainIdParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseChainIdReturnType<config extends Config = Config> =\n  GetChainIdReturnType<config>\n\n/** https://wagmi.sh/react/api/hooks/useChainId */\nexport function useChainId<config extends Config = ResolvedRegister['config']>(\n  parameters: UseChainIdParameters<config> = {},\n): UseChainIdReturnType<config> {\n  const config = useConfig(parameters)\n\n  return useSyncExternalStore(\n    (onChange) => watchChainId(config, { onChange }),\n    () => getChainId(config),\n    () => getChainId(config),\n  )\n}\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\nexport const versionedHashVersionKzg = 1\n","import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport {\n  type EstimateFeesPerGasErrorType,\n  internal_estimateFeesPerGas,\n} from '../../actions/public/estimateFeesPerGas.js'\nimport {\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  estimateGas,\n} from '../../actions/public/estimateGas.js'\nimport {\n  type GetBlockErrorType,\n  getBlock as getBlock_,\n} from '../../actions/public/getBlock.js'\nimport {\n  type GetTransactionCountErrorType,\n  getTransactionCount,\n} from '../../actions/public/getTransactionCount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { AccountNotFoundErrorType } from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport {\n  Eip1559FeesNotSupportedError,\n  MaxFeePerGasTooLowError,\n} from '../../errors/fee.js'\nimport type { DeriveAccount, GetAccountParameter } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type {\n  TransactionRequest,\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestEIP7702,\n  TransactionRequestLegacy,\n  TransactionSerializable,\n} from '../../types/transaction.js'\nimport type {\n  ExactPartial,\n  IsNever,\n  Prettify,\n  UnionOmit,\n  UnionRequiredBy,\n} from '../../types/utils.js'\nimport { blobsToCommitments } from '../../utils/blob/blobsToCommitments.js'\nimport { blobsToProofs } from '../../utils/blob/blobsToProofs.js'\nimport { commitmentsToVersionedHashes } from '../../utils/blob/commitmentsToVersionedHashes.js'\nimport { toBlobSidecars } from '../../utils/blob/toBlobSidecars.js'\nimport type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport type { NonceManager } from '../../utils/nonceManager.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport {\n  type GetTransactionType,\n  getTransactionType,\n} from '../../utils/transaction/getTransactionType.js'\nimport {\n  type FillTransactionErrorType,\n  type FillTransactionParameters,\n  fillTransaction,\n} from '../public/fillTransaction.js'\nimport { getChainId as getChainId_ } from '../public/getChainId.js'\n\nexport const defaultParameters = [\n  'blobVersionedHashes',\n  'chainId',\n  'fees',\n  'gas',\n  'nonce',\n  'type',\n] as const\n\n/** @internal */\nexport const eip1559NetworkCache = /*#__PURE__*/ new Map<string, boolean>()\n\n/** @internal */\nexport const supportsFillTransaction = /*#__PURE__*/ new LruMap<boolean>(128)\n\nexport type PrepareTransactionRequestParameterType =\n  | 'blobVersionedHashes'\n  | 'chainId'\n  | 'fees'\n  | 'gas'\n  | 'nonce'\n  | 'sidecars'\n  | 'type'\ntype ParameterTypeToParameters<\n  parameterType extends PrepareTransactionRequestParameterType,\n> = parameterType extends 'fees'\n  ? 'maxFeePerGas' | 'maxPriorityFeePerGas' | 'gasPrice'\n  : parameterType\n\nexport type PrepareTransactionRequestRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter & {\n    /**\n     * Nonce manager to use for the transaction request.\n     */\n    nonceManager?: NonceManager | undefined\n    /**\n     * Parameters to prepare for the transaction request.\n     *\n     * @default ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type']\n     */\n    parameters?: readonly PrepareTransactionRequestParameterType[] | undefined\n  }\n\nexport type PrepareTransactionRequestParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  request extends PrepareTransactionRequestRequest<\n    chain,\n    chainOverride\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, accountOverride, false, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request> & { chainId?: number | undefined }\n\nexport type PrepareTransactionRequestReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  request extends PrepareTransactionRequestRequest<\n    chain,\n    chainOverride\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\n  ///\n  _derivedAccount extends Account | Address | undefined = DeriveAccount<\n    account,\n    accountOverride\n  >,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n  _transactionType = request['type'] extends string | undefined\n    ? request['type']\n    : GetTransactionType<request> extends 'legacy'\n      ? unknown\n      : GetTransactionType<request>,\n  _transactionRequest extends TransactionRequest =\n    | (_transactionType extends 'legacy' ? TransactionRequestLegacy : never)\n    | (_transactionType extends 'eip1559' ? TransactionRequestEIP1559 : never)\n    | (_transactionType extends 'eip2930' ? TransactionRequestEIP2930 : never)\n    | (_transactionType extends 'eip4844' ? TransactionRequestEIP4844 : never)\n    | (_transactionType extends 'eip7702' ? TransactionRequestEIP7702 : never),\n> = Prettify<\n  UnionRequiredBy<\n    Extract<\n      UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n        (_derivedChain extends Chain\n          ? { chain: _derivedChain }\n          : { chain?: undefined }) &\n        (_derivedAccount extends Account\n          ? { account: _derivedAccount; from: Address }\n          : { account?: undefined; from?: undefined }),\n      IsNever<_transactionRequest> extends true\n        ? unknown\n        : ExactPartial<_transactionRequest>\n    > & { chainId?: number | undefined },\n    ParameterTypeToParameters<\n      request['parameters'] extends readonly PrepareTransactionRequestParameterType[]\n        ? request['parameters'][number]\n        : (typeof defaultParameters)[number]\n    >\n  > &\n    (unknown extends request['kzg'] ? {} : Pick<request, 'kzg'>)\n>\n\nexport type PrepareTransactionRequestErrorType =\n  | AccountNotFoundErrorType\n  | AssertRequestErrorType\n  | ParseAccountErrorType\n  | GetBlockErrorType\n  | GetTransactionCountErrorType\n  | EstimateGasErrorType\n  | EstimateFeesPerGasErrorType\n\n/**\n * Prepares a transaction request for signing.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest\n *\n * @param args - {@link PrepareTransactionRequestParameters}\n * @returns The transaction request. {@link PrepareTransactionRequestReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { prepareTransactionRequest } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const request = await prepareTransactionRequest(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareTransactionRequest } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x‚Ä¶'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const request = await prepareTransactionRequest(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function prepareTransactionRequest<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends PrepareTransactionRequestRequest<chain, chainOverride>,\n  accountOverride extends Account | Address | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: PrepareTransactionRequestParameters<\n    chain,\n    account,\n    chainOverride,\n    accountOverride,\n    request\n  >,\n): Promise<\n  PrepareTransactionRequestReturnType<\n    chain,\n    account,\n    chainOverride,\n    accountOverride,\n    request\n  >\n> {\n  let request = args as PrepareTransactionRequestParameters\n\n  request.account ??= client.account\n  request.parameters ??= defaultParameters\n\n  const {\n    account: account_,\n    chain = client.chain,\n    nonceManager,\n    parameters,\n  } = request\n\n  const prepareTransactionRequest = (() => {\n    if (typeof chain?.prepareTransactionRequest === 'function')\n      return {\n        fn: chain.prepareTransactionRequest,\n        runAt: ['beforeFillTransaction'],\n      }\n    if (Array.isArray(chain?.prepareTransactionRequest))\n      return {\n        fn: chain.prepareTransactionRequest[0],\n        runAt: chain.prepareTransactionRequest[1].runAt,\n      }\n    return undefined\n  })()\n\n  let chainId: number | undefined\n  async function getChainId(): Promise<number> {\n    if (chainId) return chainId\n    if (typeof request.chainId !== 'undefined') return request.chainId\n    if (chain) return chain.id\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})\n    chainId = chainId_\n    return chainId\n  }\n\n  const account = account_ ? parseAccount(account_) : account_\n\n  let nonce = request.nonce\n  if (\n    parameters.includes('nonce') &&\n    typeof nonce === 'undefined' &&\n    account &&\n    nonceManager\n  ) {\n    const chainId = await getChainId()\n    nonce = await nonceManager.consume({\n      address: account.address,\n      chainId,\n      client,\n    })\n  }\n\n  if (\n    prepareTransactionRequest?.fn &&\n    prepareTransactionRequest.runAt?.includes('beforeFillTransaction')\n  ) {\n    request = await prepareTransactionRequest.fn(\n      { ...request, chain },\n      {\n        phase: 'beforeFillTransaction',\n      },\n    )\n    nonce ??= request.nonce\n  }\n\n  const attemptFill = (() => {\n    // Do not attempt if blobs are provided.\n    if (\n      (parameters.includes('blobVersionedHashes') ||\n        parameters.includes('sidecars')) &&\n      request.kzg &&\n      request.blobs\n    )\n      return false\n\n    // Do not attempt if `eth_fillTransaction` is not supported.\n    if (supportsFillTransaction.get(client.uid) === false) return false\n\n    // Should attempt `eth_fillTransaction` if \"fees\" or \"gas\" are required to be populated,\n    // otherwise, can just use the other individual calls.\n    const shouldAttempt = ['fees', 'gas'].some((parameter) =>\n      parameters.includes(parameter as PrepareTransactionRequestParameterType),\n    )\n    if (!shouldAttempt) return false\n\n    // Check if `eth_fillTransaction` needs to be called.\n    if (parameters.includes('chainId') && typeof request.chainId !== 'number')\n      return true\n    if (parameters.includes('nonce') && typeof nonce !== 'number') return true\n    if (\n      parameters.includes('fees') &&\n      typeof request.gasPrice !== 'bigint' &&\n      (typeof request.maxFeePerGas !== 'bigint' ||\n        typeof (request as any).maxPriorityFeePerGas !== 'bigint')\n    )\n      return true\n    if (parameters.includes('gas') && typeof request.gas !== 'bigint')\n      return true\n    return false\n  })()\n\n  const fillResult = attemptFill\n    ? await getAction(\n        client,\n        fillTransaction,\n        'fillTransaction',\n      )({ ...request, nonce } as FillTransactionParameters)\n        .then((result) => {\n          const {\n            chainId,\n            from,\n            gas,\n            gasPrice,\n            nonce,\n            maxFeePerBlobGas,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            type,\n            ...rest\n          } = result.transaction\n          supportsFillTransaction.set(client.uid, true)\n          return {\n            ...request,\n            ...(from ? { from } : {}),\n            ...(type ? { type } : {}),\n            ...(typeof chainId !== 'undefined' ? { chainId } : {}),\n            ...(typeof gas !== 'undefined' ? { gas } : {}),\n            ...(typeof gasPrice !== 'undefined' ? { gasPrice } : {}),\n            ...(typeof nonce !== 'undefined' ? { nonce } : {}),\n            ...(typeof maxFeePerBlobGas !== 'undefined'\n              ? { maxFeePerBlobGas }\n              : {}),\n            ...(typeof maxFeePerGas !== 'undefined' ? { maxFeePerGas } : {}),\n            ...(typeof maxPriorityFeePerGas !== 'undefined'\n              ? { maxPriorityFeePerGas }\n              : {}),\n            ...('nonceKey' in rest && typeof rest.nonceKey !== 'undefined'\n              ? { nonceKey: rest.nonceKey }\n              : {}),\n          }\n        })\n        .catch((e) => {\n          const error = e as FillTransactionErrorType\n\n          if (error.name !== 'TransactionExecutionError') return request\n\n          const unsupported = error.walk?.((e) => {\n            const error = e as BaseError\n            return (\n              error.name === 'MethodNotFoundRpcError' ||\n              error.name === 'MethodNotSupportedRpcError'\n            )\n          })\n          if (unsupported) supportsFillTransaction.set(client.uid, false)\n\n          return request\n        })\n    : request\n\n  nonce ??= fillResult.nonce\n\n  request = {\n    ...(fillResult as any),\n    ...(account ? { from: account?.address } : {}),\n    ...(nonce ? { nonce } : {}),\n  }\n  const { blobs, gas, kzg, type } = request\n\n  if (\n    prepareTransactionRequest?.fn &&\n    prepareTransactionRequest.runAt?.includes('beforeFillParameters')\n  ) {\n    request = await prepareTransactionRequest.fn(\n      { ...request, chain },\n      {\n        phase: 'beforeFillParameters',\n      },\n    )\n  }\n\n  let block: Block | undefined\n  async function getBlock(): Promise<Block> {\n    if (block) return block\n    block = await getAction(\n      client,\n      getBlock_,\n      'getBlock',\n    )({ blockTag: 'latest' })\n    return block\n  }\n\n  if (\n    parameters.includes('nonce') &&\n    typeof nonce === 'undefined' &&\n    account &&\n    !nonceManager\n  )\n    request.nonce = await getAction(\n      client,\n      getTransactionCount,\n      'getTransactionCount',\n    )({\n      address: account.address,\n      blockTag: 'pending',\n    })\n\n  if (\n    (parameters.includes('blobVersionedHashes') ||\n      parameters.includes('sidecars')) &&\n    blobs &&\n    kzg\n  ) {\n    const commitments = blobsToCommitments({ blobs, kzg })\n\n    if (parameters.includes('blobVersionedHashes')) {\n      const versionedHashes = commitmentsToVersionedHashes({\n        commitments,\n        to: 'hex',\n      })\n      request.blobVersionedHashes = versionedHashes\n    }\n    if (parameters.includes('sidecars')) {\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\n      const sidecars = toBlobSidecars({\n        blobs,\n        commitments,\n        proofs,\n        to: 'hex',\n      })\n      request.sidecars = sidecars\n    }\n  }\n\n  if (parameters.includes('chainId')) request.chainId = await getChainId()\n\n  if (\n    (parameters.includes('fees') || parameters.includes('type')) &&\n    typeof type === 'undefined'\n  ) {\n    try {\n      request.type = getTransactionType(\n        request as TransactionSerializable,\n      ) as any\n    } catch {\n      let isEip1559Network = eip1559NetworkCache.get(client.uid)\n      if (typeof isEip1559Network === 'undefined') {\n        const block = await getBlock()\n        isEip1559Network = typeof block?.baseFeePerGas === 'bigint'\n        eip1559NetworkCache.set(client.uid, isEip1559Network)\n      }\n      request.type = isEip1559Network ? 'eip1559' : 'legacy'\n    }\n  }\n\n  if (parameters.includes('fees')) {\n    // TODO(4844): derive blob base fees once https://github.com/ethereum/execution-apis/pull/486 is merged.\n\n    if (request.type !== 'legacy' && request.type !== 'eip2930') {\n      // EIP-1559 fees\n      if (\n        typeof request.maxFeePerGas === 'undefined' ||\n        typeof request.maxPriorityFeePerGas === 'undefined'\n      ) {\n        const block = await getBlock()\n        const { maxFeePerGas, maxPriorityFeePerGas } =\n          await internal_estimateFeesPerGas(client, {\n            block: block as Block,\n            chain,\n            request: request as PrepareTransactionRequestParameters,\n          })\n\n        if (\n          typeof request.maxPriorityFeePerGas === 'undefined' &&\n          request.maxFeePerGas &&\n          request.maxFeePerGas < maxPriorityFeePerGas\n        )\n          throw new MaxFeePerGasTooLowError({\n            maxPriorityFeePerGas,\n          })\n\n        request.maxPriorityFeePerGas = maxPriorityFeePerGas\n        request.maxFeePerGas = maxFeePerGas\n      }\n    } else {\n      // Legacy fees\n      if (\n        typeof request.maxFeePerGas !== 'undefined' ||\n        typeof request.maxPriorityFeePerGas !== 'undefined'\n      )\n        throw new Eip1559FeesNotSupportedError()\n\n      if (typeof request.gasPrice === 'undefined') {\n        const block = await getBlock()\n        const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(\n          client,\n          {\n            block: block as Block,\n            chain,\n            request: request as PrepareTransactionRequestParameters,\n            type: 'legacy',\n          },\n        )\n        request.gasPrice = gasPrice_\n      }\n    }\n  }\n\n  if (parameters.includes('gas') && typeof gas === 'undefined')\n    request.gas = await getAction(\n      client,\n      estimateGas,\n      'estimateGas',\n    )({\n      ...request,\n      account,\n      prepare: account?.type === 'local' ? [] : ['blobVersionedHashes'],\n    } as EstimateGasParameters)\n\n  if (\n    prepareTransactionRequest?.fn &&\n    prepareTransactionRequest.runAt?.includes('afterFillParameters')\n  )\n    request = await prepareTransactionRequest.fn(\n      { ...request, chain },\n      {\n        phase: 'afterFillParameters',\n      },\n    )\n\n  assertRequest(request as AssertRequestParameters)\n\n  delete request.parameters\n\n  return request as any\n}\n","import { type QueryKey, replaceEqualDeep } from '@tanstack/query-core'\nimport type { Connector } from '../createConfig.js'\nimport type { Compute, StrictOmit } from '../types/utils.js'\n\nexport function structuralSharing<data>(\n  oldData: data | undefined,\n  newData: data,\n): data {\n  return replaceEqualDeep(oldData, newData)\n}\n\nexport function hashFn(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, value) => {\n    if (isPlainObject(value))\n      return Object.keys(value)\n        .sort()\n        .reduce((result, key) => {\n          result[key] = value[key]\n          return result\n        }, {} as any)\n    if (typeof value === 'bigint') return value.toString()\n    return value\n  })\n}\n\n// biome-ignore lint/complexity/noBannedTypes: using\nfunction isPlainObject(value: any): value is Object {\n  if (!hasObjectPrototype(value)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = value.constructor\n  if (typeof ctor === 'undefined') return true\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) return false\n\n  // If constructor does not have an Object-specific method\n  // biome-ignore lint/suspicious/noPrototypeBuiltins: using\n  if (!prot.hasOwnProperty('isPrototypeOf')) return false\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function filterQueryOptions<\n  type extends Record<string, unknown> & { connector?: Connector | undefined },\n>(\n  options: type,\n): Compute<\n  StrictOmit<type, 'abi' | 'config' | 'connector' | 'query' | 'watch'> &\n    (type extends { connector?: Connector | undefined }\n      ? { connectorUid?: string }\n      : unknown)\n> {\n  // destructuring is super fast\n  // biome-ignore format: no formatting\n  const {\n    // import('@tanstack/query-core').QueryOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    _defaulted, behavior, gcTime, initialData, initialDataUpdatedAt, maxPages, meta, networkMode, queryFn, queryHash, queryKey, queryKeyHashFn, retry, retryDelay, structuralSharing,\n\n    // import('@tanstack/query-core').InfiniteQueryObserverOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    getPreviousPageParam, getNextPageParam, initialPageParam,\n\n    // import('@tanstack/react-query').UseQueryOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    _optimisticResults, enabled, notifyOnChangeProps, placeholderData, refetchInterval, refetchIntervalInBackground, refetchOnMount, refetchOnReconnect, refetchOnWindowFocus, retryOnMount, select, staleTime, suspense, throwOnError,\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // wagmi\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    abi, config, connector, query, watch,\n    ...rest\n  } = options\n  if (connector) return { connectorUid: connector?.uid, ...rest } as never\n  return rest as never\n}\n","import type { Config } from '../createConfig.js'\nimport type { GetChainIdReturnType } from './getChainId.js'\n\nexport type WatchChainIdParameters<config extends Config = Config> = {\n  onChange(\n    chainId: GetChainIdReturnType<config>,\n    prevChainId: GetChainIdReturnType<config>,\n  ): void\n}\n\nexport type WatchChainIdReturnType = () => void\n\n/** https://wagmi.sh/core/api/actions/watchChainId */\nexport function watchChainId<config extends Config>(\n  config: config,\n  parameters: WatchChainIdParameters<config>,\n): WatchChainIdReturnType {\n  const { onChange } = parameters\n  return config.subscribe((state) => state.chainId, onChange)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { SignedAuthorizationList } from '../../types/authorization.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type {\n  Chain,\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcAuthorizationList, RpcTransaction } from '../../types/rpc.js'\nimport type { Transaction, TransactionType } from '../../types/transaction.js'\nimport type { ExactPartial, UnionLooseOmit } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\n\ntype TransactionPendingDependencies =\n  | 'blockHash'\n  | 'blockNumber'\n  | 'transactionIndex'\n\nexport type FormattedTransaction<\n  chain extends Chain | undefined = undefined,\n  blockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    chain,\n    'transaction',\n    Transaction\n  >,\n  _ExcludedPendingDependencies extends string = TransactionPendingDependencies &\n    ExtractChainFormatterExclude<chain, 'transaction'>,\n> = UnionLooseOmit<_FormatterReturnType, TransactionPendingDependencies> & {\n  [_K in _ExcludedPendingDependencies]: never\n} & Pick<\n    Transaction<bigint, number, blockTag extends 'pending' ? true : false>,\n    TransactionPendingDependencies\n  >\n\nexport const transactionType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n  '0x4': 'eip7702',\n} as const satisfies Record<Hex, TransactionType>\n\nexport type FormatTransactionErrorType = ErrorType\n\nexport function formatTransaction(\n  transaction: ExactPartial<RpcTransaction>,\n  _?: string | undefined,\n) {\n  const transaction_ = {\n    ...transaction,\n    blockHash: transaction.blockHash ? transaction.blockHash : null,\n    blockNumber: transaction.blockNumber\n      ? BigInt(transaction.blockNumber)\n      : null,\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\n    maxFeePerBlobGas: transaction.maxFeePerBlobGas\n      ? BigInt(transaction.maxFeePerBlobGas)\n      : undefined,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : undefined,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : undefined,\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\n    to: transaction.to ? transaction.to : null,\n    transactionIndex: transaction.transactionIndex\n      ? Number(transaction.transactionIndex)\n      : null,\n    type: transaction.type\n      ? (transactionType as any)[transaction.type]\n      : undefined,\n    typeHex: transaction.type ? transaction.type : undefined,\n    value: transaction.value ? BigInt(transaction.value) : undefined,\n    v: transaction.v ? BigInt(transaction.v) : undefined,\n  } as Transaction\n\n  if (transaction.authorizationList)\n    transaction_.authorizationList = formatAuthorizationList(\n      transaction.authorizationList,\n    )\n\n  transaction_.yParity = (() => {\n    // If `yParity` is provided, we will use it.\n    if (transaction.yParity) return Number(transaction.yParity)\n\n    // If no `yParity` provided, try derive from `v`.\n    if (typeof transaction_.v === 'bigint') {\n      if (transaction_.v === 0n || transaction_.v === 27n) return 0\n      if (transaction_.v === 1n || transaction_.v === 28n) return 1\n      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0\n    }\n\n    return undefined\n  })()\n\n  if (transaction_.type === 'legacy') {\n    delete transaction_.accessList\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n    delete transaction_.yParity\n  }\n  if (transaction_.type === 'eip2930') {\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n  }\n  if (transaction_.type === 'eip1559') delete transaction_.maxFeePerBlobGas\n\n  return transaction_\n}\n\nexport type DefineTransactionErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineTransaction = /*#__PURE__*/ defineFormatter(\n  'transaction',\n  formatTransaction,\n)\n\n//////////////////////////////////////////////////////////////////////////////\n\nfunction formatAuthorizationList(\n  authorizationList: RpcAuthorizationList,\n): SignedAuthorizationList {\n  return authorizationList.map((authorization) => ({\n    address: (authorization as any).address,\n    chainId: Number(authorization.chainId),\n    nonce: Number(authorization.nonce),\n    r: authorization.r,\n    s: authorization.s,\n    yParity: Number(authorization.yParity),\n  })) as SignedAuthorizationList\n}\n","import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  type ReadContractReturnType,\n  readContract,\n} from '../actions/readContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions, structuralSharing } from './utils.js'\n\nexport type ReadContractOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UnionExactPartial<ReadContractParameters<abi, functionName, args, config>> &\n  ScopeKeyParameter &\n  QueryParameter<\n    ReadContractQueryFnData<abi, functionName, args>,\n    ReadContractErrorType,\n    selectData,\n    ReadContractQueryKey<abi, functionName, args, config>\n  >\n\nexport function readContractQueryOptions<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  selectData = ReadContractData<abi, functionName, args>,\n>(\n  config: config,\n  options: ReadContractOptions<abi, functionName, args, config> = {} as any,\n): ReadContractQueryOptions<abi, functionName, args, config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      Boolean(options.address || ('code' in options && options.code)) &&\n        options.abi &&\n        options.functionName &&\n        (options.query?.enabled ?? true),\n    ),\n    // TODO: Support `signal` once Viem actions allow passthrough\n    // https://tkdodo.eu/blog/why-you-want-react-query#bonus-cancellation\n    queryFn: async (context) => {\n      if (!options.abi) throw new Error('abi is required')\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.functionName) throw new Error('functionName is required')\n      const result = await readContract(config, {\n        ...(parameters as any),\n        abi: options.abi,\n        address: parameters.address,\n        code:\n          'code' in parameters && parameters.code ? parameters.code : undefined,\n        functionName: parameters.functionName,\n      })\n      return result as ReadContractData<abi, functionName, args>\n    },\n    queryKey: readContractQueryKey(options as any) as any,\n    structuralSharing,\n  } as ReadContractQueryOptions<abi, functionName, args, config, selectData>\n}\n\nexport type ReadContractQueryFnData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ReadContractReturnType<abi, functionName, args>\n\nexport type ReadContractData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ReadContractQueryFnData<abi, functionName, args>\n\nexport function readContractQueryKey<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(\n  options: UnionExactPartial<\n    ReadContractParameters<abi, functionName, args, config>\n  > &\n    ScopeKeyParameter = {} as any,\n) {\n  return ['readContract', filterQueryOptions(options)] as const\n}\n\nexport type ReadContractQueryKey<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n> = ReturnType<typeof readContractQueryKey<config, abi, functionName, args>>\n\nexport type ReadContractQueryOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = QueryOptions<\n  ReadContractQueryFnData<abi, functionName, args>,\n  ReadContractErrorType,\n  selectData,\n  ReadContractQueryKey<abi, functionName, args, config>\n>\n","import type { Abi, Address } from 'abitype'\n\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ContractFunctionExecutionError,\n  type ContractFunctionExecutionErrorType,\n  ContractFunctionRevertedError,\n  type ContractFunctionRevertedErrorType,\n  ContractFunctionZeroDataError,\n  type ContractFunctionZeroDataErrorType,\n  RawContractError,\n} from '../../errors/contract.js'\nimport { RpcRequestError } from '../../errors/request.js'\nimport { InternalRpcError, InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\nconst EXECUTION_REVERTED_ERROR_CODE = 3\n\nexport type GetContractErrorReturnType<cause = ErrorType> = Omit<\n  ContractFunctionExecutionErrorType,\n  'cause'\n> & {\n  cause:\n    | cause\n    | ContractFunctionZeroDataErrorType\n    | ContractFunctionRevertedErrorType\n}\n\nexport function getContractError<err extends ErrorType<string>>(\n  err: err,\n  {\n    abi,\n    address,\n    args,\n    docsPath,\n    functionName,\n    sender,\n  }: {\n    abi: Abi\n    args: any\n    address?: Address | undefined\n    docsPath?: string | undefined\n    functionName: string\n    sender?: Address | undefined\n  },\n): GetContractErrorReturnType {\n  const error = (\n    err instanceof RawContractError\n      ? err\n      : err instanceof BaseError\n        ? err.walk((err) => 'data' in (err as Error)) || err.walk()\n        : {}\n  ) as BaseError\n  const { code, data, details, message, shortMessage } =\n    error as RawContractError\n\n  const cause = (() => {\n    if (err instanceof AbiDecodingZeroDataError)\n      return new ContractFunctionZeroDataError({ functionName })\n    if (\n      ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) &&\n        (data || details || message || shortMessage)) ||\n      (code === InvalidInputRpcError.code &&\n        details === 'execution reverted' &&\n        data)\n    ) {\n      return new ContractFunctionRevertedError({\n        abi,\n        data: typeof data === 'object' ? data.data : data,\n        functionName,\n        message:\n          error instanceof RpcRequestError\n            ? details\n            : (shortMessage ?? message),\n      })\n    }\n    return err\n  })()\n\n  return new ContractFunctionExecutionError(cause as BaseError, {\n    abi,\n    args,\n    contractAddress: address,\n    docsPath,\n    functionName,\n    sender,\n  }) as GetContractErrorReturnType\n}\n","import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type GetEstimateGasErrorReturnType,\n  getEstimateGasError,\n} from '../../utils/errors/getEstimateGasError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { serializeStateOverride } from '../../utils/stateOverride.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport {\n  type PrepareTransactionRequestParameters,\n  type PrepareTransactionRequestParameterType,\n  prepareTransactionRequest,\n} from '../wallet/prepareTransactionRequest.js'\n\nexport type EstimateGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedEstimateGas<chain>, 'from'> & {\n  account?: Account | Address | undefined\n  prepare?:\n    | boolean\n    | readonly PrepareTransactionRequestParameterType[]\n    | undefined\n  stateOverride?: StateOverride | undefined\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: undefined\n      }\n    | {\n        blockNumber?: undefined\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag | undefined\n      }\n  )\ntype FormattedEstimateGas<chain extends Chain | undefined = Chain | undefined> =\n  FormattedTransactionRequest<chain>\n\nexport type EstimateGasReturnType = bigint\n\nexport type EstimateGasErrorType = GetEstimateGasErrorReturnType<\n  | ParseAccountErrorType\n  | NumberToHexErrorType\n  | RequestErrorType\n  | RecoverAuthorizationAddressErrorType\n  | AssertRequestErrorType\n>\n\n/**\n * Estimates the gas necessary to complete a transaction without submitting it to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateGas\n * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateGasParameters}\n * @returns The gas estimate (in gas units). {@link EstimateGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateGas } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasEstimate = await estimateGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: EstimateGasParameters<chain>,\n): Promise<EstimateGasReturnType> {\n  const { account: account_ = client.account, prepare = true } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const parameters = (() => {\n    if (Array.isArray(prepare)) return prepare\n    // Some RPC Providers do not compute versioned hashes from blobs. We will need\n    // to compute them.\n    if (account?.type !== 'local') return ['blobVersionedHashes']\n    return undefined\n  })()\n\n  try {\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (args.to) return args.to\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (args.authorizationList && args.authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: args.authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    const {\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      blockNumber,\n      blockTag,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      value,\n      stateOverride,\n      ...rest\n    } = prepare\n      ? ((await prepareTransactionRequest(client, {\n          ...args,\n          parameters,\n          to,\n        } as PrepareTransactionRequestParameters)) as EstimateGasParameters)\n      : args\n\n    // If we get `gas` back from the prepared transaction request, which is\n    // different from the `gas` we provided, it was likely filled by other means\n    // during request preparation (e.g. `eth_fillTransaction` or `chain.transactionRequest.prepare`).\n    // (e.g. `eth_fillTransaction` or `chain.transactionRequest.prepare`).\n    if (gas && args.gas !== gas) return gas\n\n    const blockNumberHex =\n      typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const rpcStateOverride = serializeStateOverride(stateOverride)\n\n    assertRequest(args as AssertRequestParameters)\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format(\n      {\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        blobVersionedHashes,\n        data,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n      } as TransactionRequest,\n      'estimateGas',\n    )\n\n    return BigInt(\n      await client.request({\n        method: 'eth_estimateGas',\n        params: rpcStateOverride\n          ? [\n              request,\n              block ?? client.experimental_blockTag ?? 'latest',\n              rpcStateOverride,\n            ]\n          : block\n            ? [request, block]\n            : [request],\n      }),\n    )\n  } catch (err) {\n    throw getEstimateGasError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n","import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from '../actions/writeContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { MutationParameter } from '../types/query.js'\nimport type { Compute } from '../types/utils.js'\n\nexport type WriteContractOptions<\n  config extends Config,\n  context = unknown,\n> = MutationParameter<\n  WriteContractData,\n  WriteContractErrorType,\n  WriteContractVariables<\n    Abi,\n    string,\n    readonly unknown[],\n    config,\n    config['chains'][number]['id']\n  >,\n  context\n>\n\nexport function writeContractMutationOptions<config extends Config, context>(\n  config: config,\n  options: WriteContractOptions<config, context> = {},\n): WriteContractMutationOptions<config> {\n  return {\n    ...(options.mutation as any),\n    mutationFn(variables) {\n      return writeContract(config, variables)\n    },\n    mutationKey: ['writeContract'],\n  }\n}\n\nexport type WriteContractMutationOptions<config extends Config> =\n  MutationOptions<\n    WriteContractData,\n    WriteContractErrorType,\n    WriteContractVariables<\n      Abi,\n      string,\n      readonly unknown[],\n      config,\n      config['chains'][number]['id']\n    >\n  >\n\nexport type WriteContractData = Compute<WriteContractReturnType>\n\nexport type WriteContractVariables<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n> = WriteContractParameters<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  allFunctionNames\n>\n\nexport type WriteContractMutate<config extends Config, context = unknown> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => void\n\nexport type WriteContractMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => Promise<WriteContractData>\n","import { versionedHashVersionKzg } from '../constants/kzg.js'\nimport type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\n  name: 'BlobSizeTooLargeError'\n}\nexport class BlobSizeTooLargeError extends BaseError {\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n      name: 'BlobSizeTooLargeError',\n    })\n  }\n}\n\nexport type EmptyBlobErrorType = EmptyBlobError & {\n  name: 'EmptyBlobError'\n}\nexport class EmptyBlobError extends BaseError {\n  constructor() {\n    super('Blob data must not be empty.', { name: 'EmptyBlobError' })\n  }\n}\n\nexport type InvalidVersionedHashSizeErrorType =\n  InvalidVersionedHashSizeError & {\n    name: 'InvalidVersionedHashSizeError'\n  }\nexport class InvalidVersionedHashSizeError extends BaseError {\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hash\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n      name: 'InvalidVersionedHashSizeError',\n    })\n  }\n}\n\nexport type InvalidVersionedHashVersionErrorType =\n  InvalidVersionedHashVersionError & {\n    name: 'InvalidVersionedHashVersionError'\n  }\nexport class InvalidVersionedHashVersionError extends BaseError {\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hash\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${versionedHashVersionKzg}`,\n        `Received: ${version}`,\n      ],\n      name: 'InvalidVersionedHashVersionError',\n    })\n  }\n}\n","import type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlockNotFoundErrorType = BlockNotFoundError & {\n  name: 'BlockNotFoundError'\n}\nexport class BlockNotFoundError extends BaseError {\n  constructor({\n    blockHash,\n    blockNumber,\n  }: {\n    blockHash?: Hash | undefined\n    blockNumber?: bigint | undefined\n  }) {\n    let identifier = 'Block'\n    if (blockHash) identifier = `Block at hash \"${blockHash}\"`\n    if (blockNumber) identifier = `Block at number \"${blockNumber}\"`\n    super(`${identifier} could not be found.`, { name: 'BlockNotFoundError' })\n  }\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport {\n  TransactionExecutionError,\n  type TransactionExecutionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from './getNodeError.js'\n\nexport type GetTransactionErrorParameters = Omit<\n  SendTransactionParameters,\n  'account' | 'chain'\n> & {\n  account: Account | null\n  chain?: Chain | undefined\n  docsPath?: string | undefined\n}\n\nexport type GetTransactionErrorReturnType<cause = ErrorType> = Omit<\n  TransactionExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport function getTransactionError<err extends ErrorType<string>>(\n  err: err,\n  { docsPath, ...args }: GetTransactionErrorParameters,\n): GetTransactionErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getNodeError(\n      err as {} as BaseError,\n      args as GetNodeErrorParameters,\n    )\n    if (cause instanceof UnknownNodeError) return err as {} as BaseError\n    return cause\n  })()\n  return new TransactionExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetTransactionErrorReturnType<err>\n}\n","import type {\n  Abi,\n  Account,\n  Chain,\n  Client,\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from 'viem'\nimport {\n  type WriteContractErrorType as viem_WriteContractErrorType,\n  type WriteContractParameters as viem_WriteContractParameters,\n  type WriteContractReturnType as viem_WriteContractReturnType,\n  writeContract as viem_writeContract,\n} from 'viem/actions'\n\nimport type { Config } from '../createConfig.js'\nimport type { BaseErrorType, ErrorType } from '../errors/base.js'\nimport type { SelectChains } from '../types/chain.js'\nimport type {\n  ChainIdParameter,\n  ConnectorParameter,\n} from '../types/properties.js'\nimport type { Compute, UnionCompute } from '../types/utils.js'\nimport { getAction } from '../utils/getAction.js'\nimport {\n  type GetConnectorClientErrorType,\n  getConnectorClient,\n} from './getConnectorClient.js'\n\nexport type WriteContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  chains extends readonly Chain[] = SelectChains<config, chainId>,\n> = UnionCompute<\n  {\n    // TODO: Should use `UnionStrictOmit<..., 'chain'>` on `viem_WriteContractParameters` result instead\n    // temp workaround that doesn't affect runtime behavior for https://github.com/wevm/wagmi/issues/3981\n    [key in keyof chains]: viem_WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chains[key],\n      Account,\n      chains[key],\n      allFunctionNames\n    >\n  }[number] &\n    Compute<ChainIdParameter<config, chainId>> &\n    ConnectorParameter\n>\n\nexport type WriteContractReturnType = viem_WriteContractReturnType\n\nexport type WriteContractErrorType =\n  // getConnectorClient()\n  | GetConnectorClientErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n  // viem\n  | viem_WriteContractErrorType\n\n/** https://wagmi.sh/core/api/actions/writeContract */\nexport async function writeContract<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  parameters: WriteContractParameters<abi, functionName, args, config, chainId>,\n): Promise<WriteContractReturnType> {\n  const { account, chainId, connector, ...request } = parameters\n\n  let client: Client\n  if (typeof account === 'object' && account?.type === 'local')\n    client = config.getClient({ chainId })\n  else\n    client = await getConnectorClient(config, {\n      account: account ?? undefined,\n      assertChainId: false,\n      chainId,\n      connector,\n    })\n\n  const chain = (() => {\n    if (!chainId || client.chain?.id === chainId) return client.chain\n    return { id: chainId }\n  })()\n\n  const action = getAction(client, viem_writeContract, 'writeContract')\n  const hash = await action({\n    ...(request as any),\n    ...(account ? { account } : {}),\n    assertChainId: !!chainId,\n    chain,\n  })\n\n  return hash\n}\n","import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { timeoutManager } from './timeoutManager'\nimport type { ManagedTimerId } from './timeoutManager'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ManagedTimerId\n  #refetchIntervalId?: ManagedTimerId\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        if (key === 'promise') {\n          this.trackProp('data')\n          if (\n            !this.options.experimental_prefetchInRender &&\n            this.#currentThenable.status === 'pending'\n          ) {\n            this.#currentThenable.reject(\n              new Error(\n                'experimental_prefetchInRender feature flag is not enabled',\n              ),\n            )\n          }\n        }\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = timeoutManager.setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = timeoutManager.setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      timeoutManager.clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      timeoutManager.clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const hasResultData = nextResult.data !== undefined\n      const isErrorWithoutData = nextResult.status === 'error' && !hasResultData\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (isErrorWithoutData) {\n          thenable.reject(nextResult.error)\n        } else if (hasResultData) {\n          thenable.resolve(nextResult.data as TData)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (isErrorWithoutData || nextResult.data !== prevThenable.value) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (!isErrorWithoutData || nextResult.error !== prevThenable.reason) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n","import type { Abi, Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify, UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { GetMutabilityAwareValue } from '../public/simulateContract.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\nimport type { sendTransactionSync } from './sendTransactionSync.js'\n\nexport type WriteContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args,\n  false,\n  allFunctionNames\n> &\n  GetChainParameter<chain, chainOverride> &\n  Prettify<\n    GetAccountParameter<account, Account | Address, true, true> &\n      GetMutabilityAwareValue<\n        abi,\n        'nonpayable' | 'payable',\n        functionName,\n        FormattedTransactionRequest<derivedChain>['value'],\n        args\n      > & {\n        /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n        dataSuffix?: Hex | undefined\n      }\n  > &\n  UnionEvaluate<\n    UnionOmit<\n      FormattedTransactionRequest<derivedChain>,\n      'data' | 'from' | 'to' | 'value'\n    >\n  >\n\nexport type WriteContractReturnType = SendTransactionReturnType\n\nexport type WriteContractErrorType =\n  | EncodeFunctionDataErrorType\n  | AccountNotFoundErrorType\n  | ParseAccountErrorType\n  | GetContractErrorReturnType<SendTransactionErrorType>\n  | ErrorType\n\n/**\n * Executes a write function on a contract.\n *\n * - Docs: https://viem.sh/docs/contract/writeContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction ‚Äì it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport async function writeContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WriteContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<WriteContractReturnType> {\n  return writeContract.internal(\n    client,\n    sendTransaction,\n    'sendTransaction',\n    parameters,\n  ) as never\n}\n\nexport namespace writeContract {\n  export async function internal<\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'nonpayable' | 'payable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined,\n  >(\n    client: Client<Transport, chain, account>,\n    actionFn: typeof sendTransaction | typeof sendTransactionSync,\n    name: 'sendTransaction' | 'sendTransactionSync',\n    parameters: WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) {\n    const {\n      abi,\n      account: account_ = client.account,\n      address,\n      args,\n      functionName,\n      ...request\n    } = parameters as WriteContractParameters\n\n    if (typeof account_ === 'undefined')\n      throw new AccountNotFoundError({\n        docsPath: '/docs/contract/writeContract',\n      })\n    const account = account_ ? parseAccount(account_) : null\n\n    const data = encodeFunctionData({\n      abi,\n      args,\n      functionName,\n    } as EncodeFunctionDataParameters)\n\n    try {\n      return await getAction(\n        client,\n        actionFn as never,\n        name,\n      )({\n        data,\n        to: address,\n        account,\n        ...request,\n      })\n    } catch (error) {\n      throw getContractError(error as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/writeContract',\n        functionName,\n        sender: account?.address,\n      })\n    }\n  }\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { EstimateGasParameters } from '../../actions/public/estimateGas.js'\nimport type { BaseError } from '../../errors/base.js'\nimport {\n  EstimateGasExecutionError,\n  type EstimateGasExecutionErrorType,\n} from '../../errors/estimateGas.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from './getNodeError.js'\n\nexport type GetEstimateGasErrorReturnType<cause = ErrorType> = Omit<\n  EstimateGasExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport function getEstimateGasError<err extends ErrorType<string>>(\n  err: err,\n  {\n    docsPath,\n    ...args\n  }: Omit<EstimateGasParameters, 'account'> & {\n    account?: Account | undefined\n    chain?: Chain | undefined\n    docsPath?: string | undefined\n  },\n): GetEstimateGasErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getNodeError(\n      err as {} as BaseError,\n      args as GetNodeErrorParameters,\n    )\n    if (cause instanceof UnknownNodeError) return err as {} as BaseError\n    return cause\n  })()\n  return new EstimateGasExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetEstimateGasErrorReturnType<err>\n}\n","import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | CreateCursorErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { Hash, Hex } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport { concat } from '../../utils/data/concat.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\nimport {\n  defaultParameters,\n  type PrepareTransactionRequestErrorType,\n  prepareTransactionRequest,\n} from './prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionErrorType,\n  sendRawTransaction,\n} from './sendRawTransaction.js'\n\nconst supportsWalletNamespace = new LruMap<boolean>(128)\n\nexport type SendTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter\n\nexport type SendTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request> & {\n    /** Whether to assert that the client chain is on the correct chain. @default true */\n    assertChainId?: boolean | undefined\n    /** Data to append to the end of the calldata. Takes precedence over `client.dataSuffix`. */\n    dataSuffix?: Hex | undefined\n  }\n\nexport type SendTransactionReturnType = Hash\n\nexport type SendTransactionErrorType =\n  | ParseAccountErrorType\n  | GetTransactionErrorReturnType<\n      | AccountNotFoundErrorType\n      | AccountTypeNotSupportedErrorType\n      | AssertCurrentChainErrorType\n      | AssertRequestErrorType\n      | GetChainIdErrorType\n      | PrepareTransactionRequestErrorType\n      | SendRawTransactionErrorType\n      | RecoverAuthorizationAddressErrorType\n      | SignTransactionErrorType\n      | RequestErrorType\n    >\n  | ErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x‚Ä¶'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionParameters<chain, account, chainOverride, request>,\n): Promise<SendTransactionReturnType> {\n  const {\n    account: account_ = client.account,\n    assertChainId = true,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    dataSuffix = typeof client.dataSuffix === 'string'\n      ? client.dataSuffix\n      : client.dataSuffix?.value,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    type,\n    value,\n    ...rest\n  } = parameters\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  try {\n    assertRequest(parameters as AssertRequestParameters)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to\n\n      // If `to` is null, we are sending a deployment transaction.\n      if (parameters.to === null) return undefined\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`.',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId: number | undefined\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({})\n        if (assertChainId)\n          assertCurrentChain({\n            currentChainId: chainId,\n            chain,\n          })\n      }\n\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format\n      const format = chainFormat || formatTransactionRequest\n\n      const request = format(\n        {\n          // Pick out extra data that might exist on the chain's transaction request type.\n          ...extract(rest, { format: chainFormat }),\n          accessList,\n          account,\n          authorizationList,\n          blobs,\n          chainId,\n          data: data ? concat([data, dataSuffix ?? '0x']) : data,\n          gas,\n          gasPrice,\n          maxFeePerBlobGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          nonce,\n          to,\n          type,\n          value,\n        } as TransactionRequest,\n        'sendTransaction',\n      )\n\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)\n      const method = isWalletNamespaceSupported\n        ? 'wallet_sendTransaction'\n        : 'eth_sendTransaction'\n\n      try {\n        return await client.request(\n          {\n            method,\n            params: [request],\n          },\n          { retryCount: 0 },\n        )\n      } catch (e) {\n        if (isWalletNamespaceSupported === false) throw e\n\n        const error = e as BaseError\n        // If the transport does not support the method or input, attempt to use the\n        // `wallet_sendTransaction` method.\n        if (\n          error.name === 'InvalidInputRpcError' ||\n          error.name === 'InvalidParamsRpcError' ||\n          error.name === 'MethodNotFoundRpcError' ||\n          error.name === 'MethodNotSupportedRpcError'\n        ) {\n          return await client\n            .request(\n              {\n                method: 'wallet_sendTransaction',\n                params: [request],\n              },\n              { retryCount: 0 },\n            )\n            .then((hash) => {\n              supportsWalletNamespace.set(client.uid, true)\n              return hash\n            })\n            .catch((e) => {\n              const walletNamespaceError = e as BaseError\n              if (\n                walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                walletNamespaceError.name === 'MethodNotSupportedRpcError'\n              ) {\n                supportsWalletNamespace.set(client.uid, false)\n                throw error\n              }\n\n              throw walletNamespaceError\n            })\n        }\n\n        throw error\n      }\n    }\n\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(\n        client,\n        prepareTransactionRequest,\n        'prepareTransactionRequest',\n      )({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data: data ? concat([data, dataSuffix ?? '0x']) : data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        type,\n        value,\n        ...rest,\n        to,\n      } as any)\n\n      const serializer = chain?.serializers?.transaction\n      const serializedTransaction = (await account.signTransaction(request, {\n        serializer,\n      })) as Hash\n      return await getAction(\n        client,\n        sendRawTransaction,\n        'sendRawTransaction',\n      )({\n        serializedTransaction,\n      })\n    }\n\n    if (account?.type === 'smart')\n      throw new AccountTypeNotSupportedError({\n        metaMessages: [\n          'Consider using the `sendUserOperation` Action instead.',\n        ],\n        docsPath: '/docs/actions/bundler/sendUserOperation',\n        type: 'smart',\n      })\n\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n      type: (account as any)?.type,\n    })\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined,\n    })\n  }\n}\n","import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Sha256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<to>\n  return toHex(bytes) as Sha256Hash<to>\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  BaseFeeScalarError,\n  type BaseFeeScalarErrorType,\n  Eip1559FeesNotSupportedError,\n  type Eip1559FeesNotSupportedErrorType,\n} from '../../errors/fee.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type {\n  Chain,\n  ChainEstimateFeesPerGasFnParameters,\n  ChainFeesFnParameters,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesLegacy,\n  FeeValuesType,\n} from '../../types/fee.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { PrepareTransactionRequestParameters } from '../wallet/prepareTransactionRequest.js'\nimport {\n  type EstimateMaxPriorityFeePerGasErrorType,\n  internal_estimateMaxPriorityFeePerGas,\n} from './estimateMaxPriorityFeePerGas.js'\nimport { getBlock } from './getBlock.js'\nimport { type GetGasPriceErrorType, getGasPrice } from './getGasPrice.js'\n\nexport type EstimateFeesPerGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  type extends FeeValuesType = FeeValuesType,\n> = {\n  /**\n   * The type of fee values to return.\n   *\n   * - `legacy`: Returns the legacy gas price.\n   * - `eip1559`: Returns the max fee per gas and max priority fee per gas.\n   *\n   * @default 'eip1559'\n   */\n  type?: type | FeeValuesType | undefined\n} & GetChainParameter<chain, chainOverride>\n\nexport type EstimateFeesPerGasReturnType<\n  type extends FeeValuesType = FeeValuesType,\n> =\n  | (type extends 'legacy' ? FeeValuesLegacy : never)\n  | (type extends 'eip1559' ? FeeValuesEIP1559 : never)\n\nexport type EstimateFeesPerGasErrorType =\n  | BaseFeeScalarErrorType\n  | EstimateMaxPriorityFeePerGasErrorType\n  | GetGasPriceErrorType\n  | Eip1559FeesNotSupportedErrorType\n  | ErrorType\n\n/**\n * Returns an estimate for the fees per gas (in wei) for a\n * transaction to be likely included in the next block.\n * Defaults to [`chain.fees.estimateFeesPerGas`](/docs/clients/chains#fees-estimatefeespergas) if set.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateFeesPerGasParameters}\n * @returns An estimate (in wei) for the fees per gas. {@link EstimateFeesPerGasReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateFeesPerGas } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const maxPriorityFeePerGas = await estimateFeesPerGas(client)\n * // { maxFeePerGas: ..., maxPriorityFeePerGas: ... }\n */\nexport async function estimateFeesPerGas<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined,\n  type extends FeeValuesType = 'eip1559',\n>(\n  client: Client<Transport, chain>,\n  args?: EstimateFeesPerGasParameters<chain, chainOverride, type> | undefined,\n): Promise<EstimateFeesPerGasReturnType<type>> {\n  return internal_estimateFeesPerGas(client, args as any)\n}\n\nexport async function internal_estimateFeesPerGas<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined,\n  type extends FeeValuesType = 'eip1559',\n>(\n  client: Client<Transport, chain>,\n  args: EstimateFeesPerGasParameters<chain, chainOverride, type> & {\n    block?: Block | undefined\n    request?: PrepareTransactionRequestParameters<Chain, Account> | undefined\n  },\n): Promise<EstimateFeesPerGasReturnType<type>> {\n  const {\n    block: block_,\n    chain = client.chain,\n    request,\n    type = 'eip1559',\n  } = args || {}\n\n  const baseFeeMultiplier = await (async () => {\n    if (typeof chain?.fees?.baseFeeMultiplier === 'function')\n      return chain.fees.baseFeeMultiplier({\n        block: block_ as Block,\n        client,\n        request,\n      } as ChainFeesFnParameters)\n    return chain?.fees?.baseFeeMultiplier ?? 1.2\n  })()\n  if (baseFeeMultiplier < 1) throw new BaseFeeScalarError()\n\n  const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0\n  const denominator = 10 ** decimals\n  const multiply = (base: bigint) =>\n    (base * BigInt(Math.ceil(baseFeeMultiplier * denominator))) /\n    BigInt(denominator)\n\n  const block = block_\n    ? block_\n    : await getAction(client, getBlock, 'getBlock')({})\n\n  if (typeof chain?.fees?.estimateFeesPerGas === 'function') {\n    const fees = (await chain.fees.estimateFeesPerGas({\n      block: block_ as Block,\n      client,\n      multiply,\n      request,\n      type,\n    } as ChainEstimateFeesPerGasFnParameters)) as unknown as EstimateFeesPerGasReturnType<type>\n\n    if (fees !== null) return fees\n  }\n\n  if (type === 'eip1559') {\n    if (typeof block.baseFeePerGas !== 'bigint')\n      throw new Eip1559FeesNotSupportedError()\n\n    const maxPriorityFeePerGas =\n      typeof request?.maxPriorityFeePerGas === 'bigint'\n        ? request.maxPriorityFeePerGas\n        : await internal_estimateMaxPriorityFeePerGas(\n            client as Client<Transport, Chain>,\n            {\n              block: block as Block,\n              chain,\n              request,\n            },\n          )\n\n    const baseFeePerGas = multiply(block.baseFeePerGas)\n    const maxFeePerGas =\n      request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas\n\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    } as EstimateFeesPerGasReturnType<type>\n  }\n\n  const gasPrice =\n    request?.gasPrice ??\n    multiply(await getAction(client, getGasPrice, 'getGasPrice')({}))\n  return {\n    gasPrice,\n  } as EstimateFeesPerGasReturnType<type>\n}\n","import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Authorization,\n  AuthorizationRequest,\n  SignedAuthorization,\n} from '../../types/authorization.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from '../signature/recoverAddress.js'\nimport {\n  type HashAuthorizationErrorType,\n  hashAuthorization,\n} from './hashAuthorization.js'\n\nexport type RecoverAuthorizationAddressParameters<\n  authorization extends OneOf<\n    Authorization | AuthorizationRequest | SignedAuthorization\n  > = OneOf<Authorization | AuthorizationRequest | SignedAuthorization>,\n  //\n  _signature = Hex | ByteArray | OneOf<Signature | SignedAuthorization>,\n> = {\n  /**\n   * The Authorization object.\n   *\n   * - If an unsigned `authorization` is provided, the `signature` property is required.\n   * - If a signed `authorization` is provided, the `signature` property does not need to be provided.\n   */\n  authorization:\n    | authorization\n    | OneOf<Authorization | AuthorizationRequest | SignedAuthorization>\n} & (authorization extends SignedAuthorization\n  ? {\n      /** Signature of the Authorization. Not required if the `authorization` is signed. */\n      signature?: _signature | undefined\n    }\n  : {\n      /** Signature of the Authorization. Not required if the `authorization` is signed. */\n      signature: _signature\n    })\n\nexport type RecoverAuthorizationAddressReturnType = Address\n\nexport type RecoverAuthorizationAddressErrorType =\n  | HashAuthorizationErrorType\n  | RecoverAddressErrorType\n  | ErrorType\n\nexport async function recoverAuthorizationAddress<\n  const authorization extends OneOf<\n    Authorization | AuthorizationRequest | SignedAuthorization\n  >,\n>(\n  parameters: RecoverAuthorizationAddressParameters<authorization>,\n): Promise<RecoverAuthorizationAddressReturnType> {\n  const { authorization, signature } = parameters\n\n  return recoverAddress({\n    hash: hashAuthorization(authorization as AuthorizationRequest),\n    signature: (signature ?? authorization) as Signature,\n  })\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  BlockNotFoundError,\n  type BlockNotFoundErrorType,\n} from '../../errors/block.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcBlock } from '../../types/rpc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormattedBlock,\n  formatBlock,\n} from '../../utils/formatters/block.js'\n\nexport type GetBlockParameters<\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: includeTransactions | undefined\n} & (\n  | {\n      /** Hash of the block. */\n      blockHash?: Hash | undefined\n      blockNumber?: undefined\n      blockTag?: undefined\n    }\n  | {\n      blockHash?: undefined\n      /** The block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockHash?: undefined\n      blockNumber?: undefined\n      /**\n       * The block tag.\n       * @default 'latest'\n       */\n      blockTag?: blockTag | BlockTag | undefined\n    }\n)\n\nexport type GetBlockReturnType<\n  chain extends Chain | undefined = undefined,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = Prettify<FormattedBlock<chain, includeTransactions, blockTag>>\n\nexport type GetBlockErrorType =\n  | BlockNotFoundErrorType\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns information about a block at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlock\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockParameters}\n * @returns Information about the block. {@link GetBlockReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlock } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const block = await getBlock(client)\n */\nexport async function getBlock<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n>(\n  client: Client<Transport, chain, account>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag = client.experimental_blockTag ?? 'latest',\n    includeTransactions: includeTransactions_,\n  }: GetBlockParameters<includeTransactions, blockTag> = {},\n): Promise<GetBlockReturnType<chain, includeTransactions, blockTag>> {\n  const includeTransactions = includeTransactions_ ?? false\n\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let block: RpcBlock | null = null\n  if (blockHash) {\n    block = await client.request(\n      {\n        method: 'eth_getBlockByHash',\n        params: [blockHash, includeTransactions],\n      },\n      { dedupe: true },\n    )\n  } else {\n    block = await client.request(\n      {\n        method: 'eth_getBlockByNumber',\n        params: [blockNumberHex || blockTag, includeTransactions],\n      },\n      { dedupe: Boolean(blockNumberHex) },\n    )\n  }\n\n  if (!block) throw new BlockNotFoundError({ blockHash, blockNumber })\n\n  const format = client.chain?.formatters?.block?.format || formatBlock\n  return format(block, 'getBlock')\n}\n","'use client'\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  WriteContractErrorType,\n} from '@wagmi/core'\nimport type { ConfigParameter } from '@wagmi/core/internal'\nimport {\n  type WriteContractData,\n  type WriteContractMutate,\n  type WriteContractMutateAsync,\n  type WriteContractOptions,\n  type WriteContractVariables,\n  writeContractMutationOptions,\n} from '@wagmi/core/query'\nimport type { Abi } from 'viem'\nimport type { UseMutationReturnType } from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWriteContractParameters<\n  config extends Config = Config,\n  context = unknown,\n> = ConfigParameter<config> & WriteContractOptions<config, context>\n\nexport type UseWriteContractReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = UseMutationReturnType<\n  WriteContractData,\n  WriteContractErrorType,\n  WriteContractVariables<\n    Abi,\n    string,\n    readonly unknown[],\n    config,\n    config['chains'][number]['id']\n  >,\n  context,\n  WriteContractMutate<config, context>,\n  WriteContractMutateAsync<config, context>\n> & {\n  /** @deprecated use `mutate` instead */\n  writeContract: WriteContractMutate<config, context>\n  /** @deprecated use `mutateAsync` instead */\n  writeContractAsync: WriteContractMutateAsync<config, context>\n}\n\n/** https://wagmi.sh/react/api/hooks/useWriteContract */\nexport function useWriteContract<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseWriteContractParameters<config, context> = {},\n): UseWriteContractReturnType<config, context> {\n  const config = useConfig(parameters)\n  const options = writeContractMutationOptions(config, parameters)\n  const mutation = useMutation(options)\n  type Return = UseWriteContractReturnType<config, context>\n  return {\n    ...(mutation as Return),\n    writeContract: mutation.mutate as Return['mutate'],\n    writeContractAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { size } from '../data/size.js'\nimport {\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from '../encoding/fromHex.js'\nimport { toHex } from '../encoding/toHex.js'\n\nexport type RecoverPublicKeyParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverPublicKeyReturnType = Hex\n\nexport type RecoverPublicKeyErrorType =\n  | HexToNumberErrorType\n  | IsHexErrorType\n  | ErrorType\n\nexport async function recoverPublicKey({\n  hash,\n  signature,\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\n  const hashHex = isHex(hash) ? hash : toHex(hash)\n\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const { r, s, v, yParity } = signature\n      const yParityOrV = Number(yParity ?? v)!\n      const recoveryBit = toRecoveryBit(yParityOrV)\n      return new secp256k1.Signature(\n        hexToBigInt(r),\n        hexToBigInt(s),\n      ).addRecoveryBit(recoveryBit)\n    }\n\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature)\n    if (size(signatureHex) !== 65) throw new Error('invalid signature length')\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`)\n    const recoveryBit = toRecoveryBit(yParityOrV)\n    return secp256k1.Signature.fromCompact(\n      signatureHex.substring(2, 130),\n    ).addRecoveryBit(recoveryBit)\n  })()\n\n  const publicKey = signature_\n    .recoverPublicKey(hashHex.substring(2))\n    .toHex(false)\n  return `0x${publicKey}`\n}\n\nfunction toRecoveryBit(yParityOrV: number) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV\n  if (yParityOrV === 27) return 0\n  if (yParityOrV === 28) return 1\n  throw new Error('Invalid yParityOrV value')\n}\n","import {\n  type Account,\n  type Address,\n  type BaseErrorType,\n  type Client,\n  createClient,\n  custom,\n} from 'viem'\nimport { getAddress, parseAccount } from 'viem/utils'\n\nimport type { Config, Connection } from '../createConfig.js'\nimport type { ErrorType } from '../errors/base.js'\nimport {\n  ConnectorAccountNotFoundError,\n  type ConnectorAccountNotFoundErrorType,\n  ConnectorChainMismatchError,\n  type ConnectorChainMismatchErrorType,\n  ConnectorNotConnectedError,\n  type ConnectorNotConnectedErrorType,\n  ConnectorUnavailableReconnectingError,\n  type ConnectorUnavailableReconnectingErrorType,\n} from '../errors/config.js'\nimport type {\n  ChainIdParameter,\n  ConnectorParameter,\n} from '../types/properties.js'\nimport type { Compute } from '../types/utils.js'\n\nexport type GetConnectorClientParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = Compute<\n  ChainIdParameter<config, chainId> &\n    ConnectorParameter & {\n      /**\n       * Account to use for the client.\n       *\n       * - `Account | Address`: An Account MUST exist on the connector.\n       * - `null`: Account MAY NOT exist on the connector. This is useful for\n       *   actions that can infer the account from the connector (e.g. sending a\n       *   call without a connected account ‚Äì the user will be prompted to select\n       *   an account within the wallet).\n       */\n      account?: Address | Account | null | undefined\n      /**\n       * Assert that the current chain ID matches the connector's chain ID.\n       */\n      assertChainId?: boolean | undefined\n    }\n>\n\nexport type GetConnectorClientReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = Compute<\n  Client<\n    config['_internal']['transports'][chainId],\n    Extract<config['chains'][number], { id: chainId }>,\n    Account\n  >\n>\n\nexport type GetConnectorClientErrorType =\n  | ConnectorAccountNotFoundErrorType\n  | ConnectorChainMismatchErrorType\n  | ConnectorNotConnectedErrorType\n  | ConnectorUnavailableReconnectingErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n\n/** https://wagmi.sh/core/api/actions/getConnectorClient */\nexport async function getConnectorClient<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  parameters: GetConnectorClientParameters<config, chainId> = {},\n): Promise<GetConnectorClientReturnType<config, chainId>> {\n  const { assertChainId = true } = parameters\n\n  // Get connection\n  let connection: Connection | undefined\n  if (parameters.connector) {\n    const { connector } = parameters\n    if (\n      config.state.status === 'reconnecting' &&\n      !connector.getAccounts &&\n      !connector.getChainId\n    )\n      throw new ConnectorUnavailableReconnectingError({ connector })\n\n    const [accounts, chainId] = await Promise.all([\n      connector.getAccounts().catch((e) => {\n        if (parameters.account === null) return []\n        throw e\n      }),\n      connector.getChainId(),\n    ])\n    connection = {\n      accounts: accounts as readonly [Address, ...Address[]],\n      chainId,\n      connector,\n    }\n  } else connection = config.state.connections.get(config.state.current!)\n  if (!connection) throw new ConnectorNotConnectedError()\n\n  const chainId = parameters.chainId ?? connection.chainId\n\n  // Check connector using same chainId as connection\n  const connectorChainId = await connection.connector.getChainId()\n  if (assertChainId && connectorChainId !== chainId)\n    throw new ConnectorChainMismatchError({\n      connectionChainId: chainId,\n      connectorChainId,\n    })\n\n  // If connector has custom `getClient` implementation\n  type Return = GetConnectorClientReturnType<config, chainId>\n  const connector = connection.connector\n  if (connector.getClient)\n    return connector.getClient({ chainId }) as unknown as Return\n\n  // Default using `custom` transport\n  const account = parseAccount(parameters.account ?? connection.accounts[0]!)\n  if (account) account.address = getAddress(account.address) // TODO: Checksum address as part of `parseAccount`?\n\n  // If account was provided, check that it exists on the connector\n  if (\n    parameters.account &&\n    !connection.accounts.some(\n      (x) => x.toLowerCase() === account.address.toLowerCase(),\n    )\n  )\n    throw new ConnectorAccountNotFoundError({\n      address: account.address,\n      connector,\n    })\n\n  const chain = config.chains.find((chain) => chain.id === chainId)\n  const provider = (await connection.connector.getProvider({ chainId })) as {\n    request(...args: any): Promise<any>\n  }\n\n  return createClient({\n    account,\n    chain,\n    name: 'Connector Client',\n    transport: (opts) => custom(provider)({ ...opts, retryCount: 0 }),\n  }) as Return\n}\n","import type { Address } from 'abitype'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { BaseFeeScalarError } from '../../errors/fee.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  ChainFeesFnParameters,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransaction,\n  formatTransaction,\n} from '../../utils/formatters/transaction.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { NonceManager } from '../../utils/nonceManager.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\nimport { getBlock } from './getBlock.js'\nimport { getChainId as getChainId_ } from './getChainId.js'\n\nexport type FillTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetAccountParameter<account, accountOverride, false, true> &\n  GetChainParameter<chain, chainOverride> & {\n    /**\n     * Nonce manager to use for the transaction request.\n     */\n    nonceManager?: NonceManager | undefined\n  }\n\nexport type FillTransactionReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  raw: Hex\n  transaction: FormattedTransaction<_derivedChain>\n}\n\nexport type FillTransactionErrorType =\n  | GetTransactionErrorReturnType<ErrorType>\n  | ErrorType\n\n/**\n * Fills a transaction request with the necessary fields to be signed over.\n *\n * - Docs: https://viem.sh/docs/actions/public/fillTransaction\n *\n * @param client - Client to use\n * @param parameters - {@link FillTransactionParameters}\n * @returns The filled transaction. {@link FillTransactionReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { fillTransaction } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await fillTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function fillTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: FillTransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<FillTransactionReturnType<chain, chainOverride>> {\n  const {\n    account = client.account,\n    accessList,\n    authorizationList,\n    chain = client.chain,\n    blobVersionedHashes,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce: nonce_,\n    nonceManager,\n    to,\n    type,\n    value,\n    ...rest\n  } = parameters\n\n  const nonce = await (async () => {\n    if (!account) return nonce_\n    if (!nonceManager) return nonce_\n    if (typeof nonce_ !== 'undefined') return nonce_\n    const account_ = parseAccount(account)\n    const chainId = chain\n      ? chain.id\n      : await getAction(client, getChainId_, 'getChainId')({})\n    return await nonceManager.consume({\n      address: account_.address,\n      chainId,\n      client,\n    })\n  })()\n\n  assertRequest(parameters)\n\n  const chainFormat = chain?.formatters?.transactionRequest?.format\n  const format = chainFormat || formatTransactionRequest\n\n  const request = format(\n    {\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format: chainFormat }),\n      account: account ? parseAccount(account) : undefined,\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      type,\n      value,\n    } as TransactionRequest,\n    'fillTransaction',\n  )\n\n  try {\n    const response = await client.request({\n      method: 'eth_fillTransaction',\n      params: [request],\n    })\n    const format = chain?.formatters?.transaction?.format || formatTransaction\n\n    const transaction = format(response.tx)\n\n    // Remove unnecessary fields.\n    delete transaction.blockHash\n    delete transaction.blockNumber\n    delete transaction.r\n    delete transaction.s\n    delete transaction.transactionIndex\n    delete transaction.v\n    delete transaction.yParity\n\n    // Rewrite fields.\n    transaction.data = transaction.input\n\n    // Preference supplied fees (some nodes do not take these preferences).\n    if (transaction.gas) transaction.gas = parameters.gas ?? transaction.gas\n    if (transaction.gasPrice)\n      transaction.gasPrice = parameters.gasPrice ?? transaction.gasPrice\n    if (transaction.maxFeePerBlobGas)\n      transaction.maxFeePerBlobGas =\n        parameters.maxFeePerBlobGas ?? transaction.maxFeePerBlobGas\n    if (transaction.maxFeePerGas)\n      transaction.maxFeePerGas =\n        parameters.maxFeePerGas ?? transaction.maxFeePerGas\n    if (transaction.maxPriorityFeePerGas)\n      transaction.maxPriorityFeePerGas =\n        parameters.maxPriorityFeePerGas ?? transaction.maxPriorityFeePerGas\n    if (transaction.nonce)\n      transaction.nonce = parameters.nonce ?? transaction.nonce\n\n    // Build fee multiplier function.\n    const feeMultiplier = await (async () => {\n      if (typeof chain?.fees?.baseFeeMultiplier === 'function') {\n        const block = await getAction(client, getBlock, 'getBlock')({})\n        return chain.fees.baseFeeMultiplier({\n          block,\n          client,\n          request: parameters,\n        } as ChainFeesFnParameters)\n      }\n      return chain?.fees?.baseFeeMultiplier ?? 1.2\n    })()\n    if (feeMultiplier < 1) throw new BaseFeeScalarError()\n\n    const decimals = feeMultiplier.toString().split('.')[1]?.length ?? 0\n    const denominator = 10 ** decimals\n    const multiplyFee = (base: bigint) =>\n      (base * BigInt(Math.ceil(feeMultiplier * denominator))) /\n      BigInt(denominator)\n\n    // Apply fee multiplier.\n    if (transaction.maxFeePerGas && !parameters.maxFeePerGas)\n      transaction.maxFeePerGas = multiplyFee(transaction.maxFeePerGas)\n    if (transaction.gasPrice && !parameters.gasPrice)\n      transaction.gasPrice = multiplyFee(transaction.gasPrice)\n\n    return {\n      raw: response.raw,\n      transaction: {\n        from: request.from,\n        ...transaction,\n      },\n    }\n  } catch (err) {\n    throw getTransactionError(\n      err as BaseError,\n      {\n        ...parameters,\n        chain: client.chain,\n      } as never,\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type {\n  Chain,\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcBlock } from '../../types/rpc.js'\nimport type { ExactPartial, Prettify } from '../../types/utils.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { type FormattedTransaction, formatTransaction } from './transaction.js'\n\ntype BlockPendingDependencies = 'hash' | 'logsBloom' | 'nonce' | 'number'\n\nexport type FormattedBlock<\n  chain extends Chain | undefined = undefined,\n  includeTransactions extends boolean = boolean,\n  blockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    chain,\n    'block',\n    Block<bigint, includeTransactions>\n  >,\n  _ExcludedPendingDependencies extends string = BlockPendingDependencies &\n    ExtractChainFormatterExclude<chain, 'block'>,\n  _Formatted = Omit<_FormatterReturnType, BlockPendingDependencies> & {\n    [_key in _ExcludedPendingDependencies]: never\n  } & Pick<\n      Block<bigint, includeTransactions, blockTag>,\n      BlockPendingDependencies\n    >,\n  _Transactions = includeTransactions extends true\n    ? Prettify<FormattedTransaction<chain, blockTag>>[]\n    : Hash[],\n> = Omit<_Formatted, 'transactions'> & {\n  transactions: _Transactions\n}\n\nexport type FormatBlockErrorType = ErrorType\n\nexport function formatBlock(\n  block: ExactPartial<RpcBlock>,\n  _?: string | undefined,\n) {\n  const transactions = (block.transactions ?? []).map((transaction) => {\n    if (typeof transaction === 'string') return transaction\n    return formatTransaction(transaction)\n  })\n  return {\n    ...block,\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n    excessBlobGas: block.excessBlobGas\n      ? BigInt(block.excessBlobGas)\n      : undefined,\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\n    hash: block.hash ? block.hash : null,\n    logsBloom: block.logsBloom ? block.logsBloom : null,\n    nonce: block.nonce ? block.nonce : null,\n    number: block.number ? BigInt(block.number) : null,\n    size: block.size ? BigInt(block.size) : undefined,\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n    transactions,\n    totalDifficulty: block.totalDifficulty\n      ? BigInt(block.totalDifficulty)\n      : null,\n  } as Block\n}\n\nexport type DefineBlockErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock)\n","import { BaseError } from './base.js'\n\nexport type AccountNotFoundErrorType = AccountNotFoundError & {\n  name: 'AccountNotFoundError'\n}\nexport class AccountNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath?: string | undefined } = {}) {\n    super(\n      [\n        'Could not find an Account to execute with this Action.',\n        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',\n      ].join('\\n'),\n      {\n        docsPath,\n        docsSlug: 'account',\n        name: 'AccountNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AccountTypeNotSupportedErrorType = AccountTypeNotSupportedError & {\n  name: 'AccountTypeNotSupportedError'\n}\nexport class AccountTypeNotSupportedError extends BaseError {\n  constructor({\n    docsPath,\n    metaMessages,\n    type,\n  }: {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n    type: string\n  }) {\n    super(`Account type \"${type}\" is not supported.`, {\n      docsPath,\n      metaMessages,\n      name: 'AccountTypeNotSupportedError',\n    })\n  }\n}\n","import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParametersError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { splitParameters } from './runtime/utils.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { SplitParameters } from './types/utils.js'\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * type Result = ParseAbiParameters<\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n> =\n  | (params extends string\n      ? params extends ''\n        ? never\n        : string extends params\n          ? readonly AbiParameter[]\n          : ParseAbiParameters_<SplitParameters<params>, { modifier: Modifier }>\n      : never)\n  | (params extends readonly string[]\n      ? string[] extends params\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<params> extends infer structs\n          ? {\n              [key in keyof params]: params[key] extends string\n                ? IsStructSignature<params[key]> extends true\n                  ? never\n                  : ParseAbiParameters_<\n                      SplitParameters<params[key]>,\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends readonly [...infer content]\n              ? content['length'] extends 0\n                ? never\n                : DeepFlatten<content>\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Flatten all members of {@link T}\n *\n * @param T - List of items to flatten\n * @param Acc - The accumulator used while recursing\n * @returns The flattened array\n *\n * @example\n * type Result = DeepFlatten<[['a', 'b'], [['c']]]>\n * //   ^? type Result = ['a', 'b', 'c']\n */\ntype DeepFlatten<\n  T extends readonly unknown[],\n  Acc extends readonly unknown[] = readonly [],\n> = T extends readonly [infer head, ...infer tail]\n  ? tail extends undefined\n    ? never\n    : head extends readonly unknown[]\n      ? DeepFlatten<tail, readonly [...Acc, ...DeepFlatten<head>]>\n      : DeepFlatten<tail, readonly [...Acc, head]>\n  : Acc\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n>(\n  params: Narrow<params> &\n    (\n      | (params extends string\n          ? params extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (params extends readonly string[]\n          ? params extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends params\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameters<params> {\n  const abiParameters: AbiParameter[] = []\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params)\n    const length = parameters.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\n    }\n  } else {\n    const structs = parseStructs(params as readonly string[])\n    const length = params.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (params as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      const parameters = splitParameters(signature)\n      const length = parameters.length\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\n        )\n      }\n    }\n  }\n\n  if (abiParameters.length === 0)\n    throw new InvalidAbiParametersError({ params })\n\n  return abiParameters as ParseAbiParameters<params>\n}\n","import type { Account } from '../accounts/types.js'\nimport type { EstimateGasParameters } from '../actions/public/estimateGas.js'\nimport type { Chain } from '../types/chain.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\nimport { prettyPrint } from './transaction.js'\n\nexport type EstimateGasExecutionErrorType = EstimateGasExecutionError & {\n  name: 'EstimateGasExecutionError'\n}\nexport class EstimateGasExecutionError extends BaseError {\n  override cause: BaseError\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<EstimateGasParameters<any>, 'account'> & {\n      account?: Account | undefined\n      chain?: Chain | undefined\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Estimate Gas Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n      name: 'EstimateGasExecutionError',\n    })\n    this.cause = cause\n  }\n}\n","'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  NoInfer,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { AuthorizationRequest } from '../../types/authorization.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type NumberToHexErrorType, numberToHex } from '../encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashAuthorizationParameters<to extends To> =\n  AuthorizationRequest & {\n    /** Output format. @default \"hex\" */\n    to?: to | To | undefined\n  }\n\nexport type HashAuthorizationReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashAuthorizationErrorType =\n  | Keccak256ErrorType\n  | ConcatHexErrorType\n  | ToRlpErrorType\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n */\nexport function hashAuthorization<to extends To = 'hex'>(\n  parameters: HashAuthorizationParameters<to>,\n): HashAuthorizationReturnType<to> {\n  const { chainId, nonce, to } = parameters\n  const address = parameters.contractAddress ?? parameters.address\n  const hash = keccak256(\n    concatHex([\n      '0x05',\n      toRlp([\n        chainId ? numberToHex(chainId) : '0x',\n        address,\n        nonce ? numberToHex(nonce) : '0x',\n      ]),\n    ]),\n  )\n  if (to === 'bytes') return hexToBytes(hash) as HashAuthorizationReturnType<to>\n  return hash as HashAuthorizationReturnType<to>\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  Eip1559FeesNotSupportedError,\n  type Eip1559FeesNotSupportedErrorType,\n} from '../../errors/fee.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type {\n  Chain,\n  ChainFeesFnParameters,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type HexToBigIntErrorType,\n  hexToBigInt,\n} from '../../utils/encoding/fromHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { PrepareTransactionRequestParameters } from '../wallet/prepareTransactionRequest.js'\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport { type GetGasPriceErrorType, getGasPrice } from './getGasPrice.js'\n\nexport type EstimateMaxPriorityFeePerGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = GetChainParameter<chain, chainOverride>\n\nexport type EstimateMaxPriorityFeePerGasReturnType = bigint\n\nexport type EstimateMaxPriorityFeePerGasErrorType =\n  | GetBlockErrorType\n  | HexToBigIntErrorType\n  | RequestErrorType\n  | GetBlockErrorType\n  | GetGasPriceErrorType\n  | Eip1559FeesNotSupportedErrorType\n  | ErrorType\n\n/**\n * Returns an estimate for the max priority fee per gas (in wei) for a\n * transaction to be likely included in the next block.\n * Defaults to [`chain.fees.defaultPriorityFee`](/docs/clients/chains#fees-defaultpriorityfee) if set.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas\n *\n * @param client - Client to use\n * @returns An estimate (in wei) for the max priority fee per gas. {@link EstimateMaxPriorityFeePerGasReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateMaxPriorityFeePerGas } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const maxPriorityFeePerGas = await estimateMaxPriorityFeePerGas(client)\n * // 10000000n\n */\nexport async function estimateMaxPriorityFeePerGas<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  args?:\n    | EstimateMaxPriorityFeePerGasParameters<chain, chainOverride>\n    | undefined,\n): Promise<EstimateMaxPriorityFeePerGasReturnType> {\n  return internal_estimateMaxPriorityFeePerGas(client, args as any)\n}\n\nexport async function internal_estimateMaxPriorityFeePerGas<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  args: EstimateMaxPriorityFeePerGasParameters<chain, chainOverride> & {\n    block?: Block | undefined\n    request?:\n      | PrepareTransactionRequestParameters<\n          chain,\n          Account | undefined,\n          chainOverride\n        >\n      | undefined\n  },\n): Promise<EstimateMaxPriorityFeePerGasReturnType> {\n  const { block: block_, chain = client.chain, request } = args || {}\n\n  try {\n    const maxPriorityFeePerGas =\n      chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee\n\n    if (typeof maxPriorityFeePerGas === 'function') {\n      const block =\n        block_ || (await getAction(client, getBlock, 'getBlock')({}))\n      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({\n        block,\n        client,\n        request,\n      } as ChainFeesFnParameters)\n      if (maxPriorityFeePerGas_ === null) throw new Error()\n      return maxPriorityFeePerGas_\n    }\n\n    if (typeof maxPriorityFeePerGas !== 'undefined') return maxPriorityFeePerGas\n\n    const maxPriorityFeePerGasHex = await client.request({\n      method: 'eth_maxPriorityFeePerGas',\n    })\n    return hexToBigInt(maxPriorityFeePerGasHex)\n  } catch {\n    // If the RPC Provider does not support `eth_maxPriorityFeePerGas`\n    // fall back to calculating it manually via `gasPrice - baseFeePerGas`.\n    // See: https://github.com/ethereum/pm/issues/328#:~:text=eth_maxPriorityFeePerGas%20after%20London%20will%20effectively%20return%20eth_gasPrice%20%2D%20baseFee\n    const [block, gasPrice] = await Promise.all([\n      block_\n        ? Promise.resolve(block_)\n        : getAction(client, getBlock, 'getBlock')({}),\n      getAction(client, getGasPrice, 'getGasPrice')({}),\n    ])\n\n    if (typeof block.baseFeePerGas !== 'bigint')\n      throw new Eip1559FeesNotSupportedError()\n\n    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas\n\n    if (maxPriorityFeePerGas < 0n) return 0n\n    return maxPriorityFeePerGas\n  }\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","import type {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Address,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\n\nimport {\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  BytesSizeMismatchError,\n  type BytesSizeMismatchErrorType,\n  UnsupportedPackedAbiType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<\n  packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n> = {\n  [K in keyof packedAbiTypes]: packedAbiTypes[K] extends AbiType\n    ? AbiParameterToPrimitiveType<{ type: packedAbiTypes[K] }>\n    : unknown\n}\n\nexport type EncodePackedErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | ConcatHexErrorType\n  | EncodeErrorType\n  | ErrorType\n\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: EncodePackedValues<packedAbiTypes>): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concatHex(data)\n}\n\ntype EncodeErrorType =\n  | BoolToHexErrorType\n  | BytesSizeMismatchErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | PadErrorType\n  | StringToHexErrorType\n  | UnsupportedPackedAbiType\n  | ErrorType\n\nfunction encode<const packedAbiType extends PackedAbiType | unknown>(\n  type: packedAbiType,\n  value: EncodePackedValues<[packedAbiType]>[0],\n  isArray = false,\n): Hex {\n  if (type === 'address') {\n    const address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = Number.parseInt(bits, 10) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (Number.parseInt(size, 10) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size, 10),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    const data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    if (data.length === 0) return '0x'\n    return concatHex(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n","import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport {\n  type ReadContractErrorType as viem_ReadContractErrorType,\n  type ReadContractParameters as viem_ReadContractParameters,\n  type ReadContractReturnType as viem_ReadContractReturnType,\n  readContract as viem_readContract,\n} from 'viem/actions'\n\nimport type { Config } from '../createConfig.js'\nimport type { ChainIdParameter } from '../types/properties.js'\nimport { getAction } from '../utils/getAction.js'\n\nexport type ReadContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = Config,\n> = viem_ReadContractParameters<abi, functionName, args> &\n  ChainIdParameter<config>\n\nexport type ReadContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = viem_ReadContractReturnType<abi, functionName, args>\n\nexport type ReadContractErrorType = viem_ReadContractErrorType\n\n/** https://wagmi.sh/core/api/actions/readContract */\nexport function readContract<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(\n  config: config,\n  parameters: ReadContractParameters<abi, functionName, args, config>,\n): Promise<ReadContractReturnType<abi, functionName, args>> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  const action = getAction(client, viem_readContract, 'readContract')\n  return action(rest as any)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type CreateTransportErrorType,\n  createTransport,\n  type Transport,\n  type TransportConfig,\n} from './createTransport.js'\n\ntype EthereumProvider = { request(...args: any): Promise<any> }\n\nexport type CustomTransportConfig = {\n  /** The key of the transport. */\n  key?: TransportConfig['key'] | undefined\n  /** Methods to include or exclude from executing RPC requests. */\n  methods?: TransportConfig['methods'] | undefined\n  /** The name of the transport. */\n  name?: TransportConfig['name'] | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n}\n\nexport type CustomTransport = Transport<\n  'custom',\n  {},\n  EthereumProvider['request']\n>\n\nexport type CustomTransportErrorType = CreateTransportErrorType | ErrorType\n\n/**\n * @description Creates a custom transport given an EIP-1193 compliant `request` attribute.\n */\nexport function custom<provider extends EthereumProvider>(\n  provider: provider,\n  config: CustomTransportConfig = {},\n): CustomTransport {\n  const {\n    key = 'custom',\n    methods,\n    name = 'Custom Provider',\n    retryDelay,\n  } = config\n  return ({ retryCount: defaultRetryCount }) =>\n    createTransport({\n      key,\n      methods,\n      name,\n      request: provider.request.bind(provider),\n      retryCount: config.retryCount ?? defaultRetryCount,\n      retryDelay,\n      type: 'custom',\n    })\n}\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => {\n  const throwOnError =\n    query?.state.error && typeof options.throwOnError === 'function'\n      ? shouldThrowError(options.throwOnError, [query.state.error, query])\n      : options.throwOnError\n\n  if (\n    options.suspense ||\n    options.experimental_prefetchInRender ||\n    throwOnError\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n","import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n    const MIN_SUSPENSE_TIME_MS = 1000\n\n    const clamp = (value: number | 'static' | undefined) =>\n      value === 'static'\n        ? value\n        : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS)\n\n    const originalStaleTime = defaultedOptions.staleTime\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => clamp(originalStaleTime(...args))\n        : clamp(originalStaleTime)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(\n        defaultedOptions.gcTime,\n        MIN_SUSPENSE_TIME_MS,\n      )\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n","import type {\n  Account,\n  Chain,\n  Client,\n  PublicActions,\n  RpcSchema,\n  Transport,\n  WalletActions,\n} from 'viem'\n\n/**\n * Retrieves and returns an action from the client (if exists), and falls\n * back to the tree-shakable action.\n *\n * Useful for extracting overridden actions from a client (ie. if a consumer\n * wants to override the `sendTransaction` implementation).\n */\nexport function getAction<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  rpcSchema extends RpcSchema | undefined,\n  extended extends { [key: string]: unknown },\n  client extends Client<transport, chain, account, rpcSchema, extended>,\n  parameters,\n  returnType,\n>(\n  client: client,\n  actionFn: (_: any, parameters: parameters) => returnType,\n  // Some minifiers drop `Function.prototype.name`, or replace it with short letters,\n  // meaning that `actionFn.name` will not always work. For that case, the consumer\n  // needs to pass the name explicitly.\n  name: keyof PublicActions | keyof WalletActions,\n): (parameters: parameters) => returnType {\n  const action_implicit = client[actionFn.name]\n  if (typeof action_implicit === 'function')\n    return action_implicit as (params: parameters) => returnType\n\n  const action_explicit = client[name]\n  if (typeof action_explicit === 'function')\n    return action_explicit as (params: parameters) => returnType\n\n  return (params) => actionFn(client, params)\n}\n","import { formatGwei } from '../utils/unit/formatGwei.js'\nimport { BaseError } from './base.js'\n\nexport type BaseFeeScalarErrorType = BaseFeeScalarError & {\n  name: 'BaseFeeScalarError'\n}\nexport class BaseFeeScalarError extends BaseError {\n  constructor() {\n    super('`baseFeeMultiplier` must be greater than 1.', {\n      name: 'BaseFeeScalarError',\n    })\n  }\n}\n\nexport type Eip1559FeesNotSupportedErrorType = Eip1559FeesNotSupportedError & {\n  name: 'Eip1559FeesNotSupportedError'\n}\nexport class Eip1559FeesNotSupportedError extends BaseError {\n  constructor() {\n    super('Chain does not support EIP-1559 fees.', {\n      name: 'Eip1559FeesNotSupportedError',\n    })\n  }\n}\n\nexport type MaxFeePerGasTooLowErrorType = MaxFeePerGasTooLowError & {\n  name: 'MaxFeePerGasTooLowError'\n}\nexport class MaxFeePerGasTooLowError extends BaseError {\n  constructor({ maxPriorityFeePerGas }: { maxPriorityFeePerGas: bigint }) {\n    super(\n      `\\`maxFeePerGas\\` cannot be less than the \\`maxPriorityFeePerGas\\` (${formatGwei(\n        maxPriorityFeePerGas,\n      )} gwei).`,\n      { name: 'MaxFeePerGasTooLowError' },\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\n\nexport type PublicKeyToAddressErrorType =\n  | ChecksumAddressErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\n/**\n * @description Converts an ECDSA public key to an address.\n *\n * @param publicKey The public key to convert.\n *\n * @returns The address.\n */\nexport function publicKeyToAddress(publicKey: Hex): Address {\n  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26)\n  return checksumAddress(`0x${address}`) as Address\n}\n","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA224 as SHA224n,\n  sha224 as sha224n,\n  SHA256 as SHA256n,\n  sha256 as sha256n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256: typeof SHA256n = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256: typeof sha256n = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224: typeof SHA224n = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224: typeof sha224n = sha224n;\n","import type { Client } from '../clients/createClient.js'\nimport type { PublicActions } from '../clients/decorators/public.js'\nimport type { WalletActions } from '../clients/decorators/wallet.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { Account } from '../types/account.js'\nimport type { Chain } from '../types/chain.js'\nimport type { RpcSchema } from '../types/eip1193.js'\n\n/**\n * Retrieves and returns an action from the client (if exists), and falls\n * back to the tree-shakable action.\n *\n * Useful for extracting overridden actions from a client (ie. if a consumer\n * wants to override the `sendTransaction` implementation).\n */\nexport function getAction<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  rpcSchema extends RpcSchema | undefined,\n  extended extends { [key: string]: unknown },\n  client extends Client<transport, chain, account, rpcSchema, extended>,\n  parameters,\n  returnType,\n>(\n  client: client,\n  actionFn: (_: any, parameters: parameters) => returnType,\n  // Some minifiers drop `Function.prototype.name`, or replace it with short letters,\n  // meaning that `actionFn.name` will not always work. For that case, the consumer\n  // needs to pass the name explicitly.\n  name: keyof PublicActions | keyof WalletActions | (string & {}),\n): (parameters: parameters) => returnType {\n  const action_implicit = client[actionFn.name]\n  if (typeof action_implicit === 'function')\n    return action_implicit as (params: parameters) => returnType\n\n  const action_explicit = client[name]\n  if (typeof action_explicit === 'function')\n    return action_explicit as (params: parameters) => returnType\n\n  return (params) => actionFn(client, params)\n}\n","/**\n * Bit-packed prediction encoding for ArenaEngine V3.\n *\n * Predictions are boolean arrays (true = UP, false = DOWN).\n * They are packed into uint256[] words, 256 bits per word.\n * Bit i of the overall tape corresponds to tick i:\n *   word index = Math.floor(i / 256)\n *   bit index  = i % 256\n *   bit value  = 1 means UP, 0 means DOWN\n *\n * For 1500 ticks: ceil(1500/256) = 6 words.\n */\n\n/** Encode a boolean prediction array into uint256[] words */\nexport function encodePredictions(predictions: boolean[]): bigint[] {\n  const wordCount = Math.ceil(predictions.length / 256);\n  const words: bigint[] = new Array(wordCount).fill(0n);\n\n  for (let i = 0; i < predictions.length; i++) {\n    if (predictions[i]) {\n      const wordIdx = Math.floor(i / 256);\n      const bitIdx = i % 256;\n      words[wordIdx] |= 1n << BigInt(bitIdx);\n    }\n  }\n\n  return words;\n}\n\n/** Decode uint256[] words back into a boolean array */\nexport function decodePredictions(words: bigint[], ticks: number): boolean[] {\n  const result: boolean[] = new Array(ticks).fill(false);\n\n  for (let i = 0; i < ticks; i++) {\n    const wordIdx = Math.floor(i / 256);\n    const bitIdx = i % 256;\n    if (wordIdx < words.length && (words[wordIdx] & (1n << BigInt(bitIdx))) !== 0n) {\n      result[i] = true;\n    }\n  }\n\n  return result;\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type BlobsToCommitmentsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[] =\n    | readonly ByteArray[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform into commitments. */\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type BlobsToCommitmentsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type BlobsToCommitmentsErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Compute commitments from a list of blobs.\n *\n * @example\n * ```ts\n * import { blobsToCommitments, toBlobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * ```\n */\nexport function blobsToCommitments<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\n): BlobsToCommitmentsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const commitments: ByteArray[] = []\n  for (const blob of blobs)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (to === 'bytes'\n    ? commitments\n    : commitments.map((x) =>\n        bytesToHex(x),\n      )) as {} as BlobsToCommitmentsReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentToVersionedHashParameters<\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\n  to extends To | undefined = undefined,\n> = {\n  /** Commitment from blob. */\n  commitment: commitment | Uint8Array | Hex\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hash. */\n  version?: number | undefined\n}\n\nexport type CommitmentToVersionedHashReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type CommitmentToVersionedHashErrorType =\n  | Sha256ErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Transform a commitment to it's versioned hash.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentToVersionedHash,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const [commitment] = blobsToCommitments({ blobs, kzg })\n * const versionedHash = commitmentToVersionedHash({ commitment })\n * ```\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex | ByteArray,\n  to extends To =\n    | (commitment extends Hex ? 'hex' : never)\n    | (commitment extends ByteArray ? 'bytes' : never),\n>(\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\n): CommitmentToVersionedHashReturnType<to> {\n  const { commitment, version = 1 } = parameters\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\n\n  const versionedHash = sha256(commitment, 'bytes')\n  versionedHash.set([version], 0)\n  return (\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\n  ) as CommitmentToVersionedHashReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type blobsToProofsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[],\n  commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Blobs to transform into proofs. */\n  blobs: blobs\n  /** Commitments for the blobs. */\n  commitments: commitments &\n    (commitments extends _blobsType\n      ? {}\n      : `commitments must be the same type as blobs`)\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type blobsToProofsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray[] : never)\n  | (to extends 'hex' ? Hex[] : never)\n\nexport type blobsToProofsErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  const commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\n): blobsToProofsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n  const commitments = (\n    typeof parameters.commitments[0] === 'string'\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\n      : parameters.commitments\n  ) as ByteArray[]\n\n  const proofs: ByteArray[] = []\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i]\n    const commitment = commitments[i]\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (to === 'bytes'\n    ? proofs\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\n}\n","'use client'\nimport * as React from 'react'\n\nimport { isServer, noop, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const client = useQueryClient(queryClient)\n  const defaultedOptions = client.defaultQueryOptions(options)\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  const query = client\n    .getQueryCache()\n    .get<\n      TQueryFnData,\n      TError,\n      TQueryData,\n      TQueryKey\n    >(defaultedOptions.queryHash)\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary, query)\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query,\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        query?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetGasPriceReturnType = bigint\n\nexport type GetGasPriceErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the current price of gas (in wei).\n *\n * - Docs: https://viem.sh/docs/actions/public/getGasPrice\n * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)\n *\n * @param client - Client to use\n * @returns The gas price (in wei). {@link GetGasPriceReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getGasPrice } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasPrice = await getGasPrice(client)\n */\nexport async function getGasPrice<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>): Promise<GetGasPriceReturnType> {\n  const gasPrice = await client.request({\n    method: 'eth_gasPrice',\n  })\n  return BigInt(gasPrice)\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type HexToNumberErrorType,\n  hexToNumber,\n} from '../../utils/encoding/fromHex.js'\n\nexport type GetChainIdReturnType = number\n\nexport type GetChainIdErrorType =\n  | HexToNumberErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the chain ID associated with the current network.\n *\n * - Docs: https://viem.sh/docs/actions/public/getChainId\n * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n *\n * @param client - Client to use\n * @returns The current chain ID. {@link GetChainIdReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getChainId } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const chainId = await getChainId(client)\n * // 1\n */\nexport async function getChainId<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>): Promise<GetChainIdReturnType> {\n  const chainIdHex = await client.request(\n    {\n      method: 'eth_chainId',\n    },\n    { dedupe: true },\n  )\n  return hexToNumber(chainIdHex)\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionSerializedGeneric } from '../../types/transaction.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SendRawTransactionParameters = {\n  /** The signed serialized transaction. */\n  serializedTransaction: TransactionSerializedGeneric\n}\n\nexport type SendRawTransactionReturnType = Hash\n\nexport type SendRawTransactionErrorType = RequestErrorType | ErrorType\n\n/**\n * Sends a **signed** transaction to the network\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction\n * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param client - Client to use\n * @param parameters - {@link SendRawTransactionParameters}\n * @returns The transaction hash. {@link SendRawTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendRawTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const hash = await sendRawTransaction(client, {\n *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n * })\n */\nexport async function sendRawTransaction<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { serializedTransaction }: SendRawTransactionParameters,\n): Promise<SendRawTransactionReturnType> {\n  return client.request(\n    {\n      method: 'eth_sendRawTransaction',\n      params: [serializedTransaction],\n    },\n    { retryCount: 0 },\n  )\n}\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type HexToNumberErrorType,\n  hexToNumber,\n} from '../../utils/encoding/fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetTransactionCountParameters = {\n  /** The account address. */\n  address: Address\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag | undefined\n    }\n)\nexport type GetTransactionCountReturnType = number\n\nexport type GetTransactionCountErrorType =\n  | RequestErrorType\n  | NumberToHexErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\n/**\n * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms#transaction) an Account has sent.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionCount\n * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionCountParameters}\n * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionCount = await getTransactionCount(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function getTransactionCount<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  { address, blockTag = 'latest', blockNumber }: GetTransactionCountParameters,\n): Promise<GetTransactionCountReturnType> {\n  const count = await client.request(\n    {\n      method: 'eth_getTransactionCount',\n      params: [\n        address,\n        typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : blockTag,\n      ],\n    },\n    {\n      dedupe: Boolean(blockNumber),\n    },\n  )\n  return hexToNumber(count)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { BlobSidecars } from '../../types/eip4844.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from './blobsToCommitments.js'\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobSidecarsParameters<\n  data extends Hex | ByteArray | undefined = undefined,\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Return type. */\n  to?: to | To | undefined\n} & OneOf<\n  | {\n      /** Data to transform into blobs. */\n      data: data | Hex | ByteArray\n      /** KZG implementation. */\n      kzg: Kzg\n    }\n  | {\n      /** Blobs. */\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\n      /** Commitment for each blob. */\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\n      /** Proof for each blob. */\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\n    }\n>\n\nexport type ToBlobSidecarsReturnType<to extends To> =\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\n\nexport type ToBlobSidecarsErrorType =\n  | BlobsToCommitmentsErrorType\n  | ToBlobsErrorType\n  | blobsToProofsErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * ```\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs,\n *   blobsToProofs,\n *   toBlobSidecars,\n *   stringToHex\n * } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n *\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\n * ```\n */\nexport function toBlobSidecars<\n  const data extends Hex | ByteArray | undefined = undefined,\n  const blobs extends\n    | readonly Hex[]\n    | readonly ByteArray[]\n    | undefined = undefined,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never)\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\n): ToBlobSidecarsReturnType<to> {\n  const { data, kzg, to } = parameters\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\n  const commitments =\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\n  const proofs =\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\n\n  const sidecars: BlobSidecars = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i],\n      commitment: commitments[i],\n      proof: proofs[i],\n    })\n\n  return sidecars as ToBlobSidecarsReturnType<to>\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,79,80,81,82,83,84,85,86,87,88]}